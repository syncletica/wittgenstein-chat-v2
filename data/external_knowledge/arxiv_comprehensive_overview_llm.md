# A Comprehensive Overview of Large Language Models

###### Abstract

Large Language Models (LLMs) have recently demonstrated remarkable capabilities in natural language processing tasks and beyond. This success of LLMs has led to a large influx of research contributions in this direction. These works encompass diverse topics such as architectural innovations, better training strategies, context length improvements, fine-tuning, multi-modal LLMs, robotics, datasets, benchmarking, efficiency, and more. With the rapid development of techniques and regular breakthroughs in LLM research, it has become considerably challenging to perceive the bigger picture of the advances in this direction. Considering the rapidly emerging plethora of literature on LLMs, it is imperative that the research community is able to benefit from a concise yet comprehensive overview of the recent developments in this field. This article provides an overview of the literature on a broad range of LLM-related concepts. Our self-contained comprehensive overview of LLMs discusses relevant background concepts along with covering the advanced topics at the frontier of research in LLMs. This review article is intended to provide not only a systematic survey but also a quick, comprehensive reference for the researchers and practitioners to draw insights from extensive, informative summaries of the existing works to advance the LLM research.

## 1 Introduction

Language plays a fundamental role in facilitating communication and self-expression for humans and their interaction with machines. The need for generalized models stems from the growing demand for machines to handle complex language tasks, including translation, summarization, information retrieval, conversational interactions, etc. Recently, significant breakthroughs have been witnessed in language models, primarily attributed to transformers \[[1](https://arxiv.org/html/2307.06435v10#bib.bib1)\], increased computational capabilities, and the availability of large-scale training data. These developments have brought about a revolutionary transformation by enabling the creation of LLMs that can approximate human-level performance on various tasks \[[2](https://arxiv.org/html/2307.06435v10#bib.bib2), [3](https://arxiv.org/html/2307.06435v10#bib.bib3)\]. Large Language Models (LLMs) have emerged as cutting-edge artificial intelligence systems that can process and generate text with coherent communication \[[4](https://arxiv.org/html/2307.06435v10#bib.bib4)\] and generalize to multiple tasks \[[5](https://arxiv.org/html/2307.06435v10#bib.bib5), [6](https://arxiv.org/html/2307.06435v10#bib.bib6)\].  
The historical progress in natural language processing (NLP) evolved from statistical to neural language modeling and then from pre-trained language models (PLMs) to LLMs. While conventional language modeling (LM) trains task-specific models in supervised settings, PLMs are trained in a self-supervised setting on a large corpus of text \[[7](https://arxiv.org/html/2307.06435v10#bib.bib7), [8](https://arxiv.org/html/2307.06435v10#bib.bib8), [9](https://arxiv.org/html/2307.06435v10#bib.bib9)\] with the aim of learning a generic representation that is shareable among various NLP tasks. After fine-tuning for downstream tasks, PLMs surpass the performance gains of traditional language modeling (LM). The larger PLMs bring more performance gains, which has led to the transitioning of PLMs to LLMs by significantly increasing model parameters (tens to hundreds of billions) \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\] and training dataset (many GBs and TBs) \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10), [11](https://arxiv.org/html/2307.06435v10#bib.bib11)\]. Following this development, numerous LLMs have been proposed in the literature \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10), [11](https://arxiv.org/html/2307.06435v10#bib.bib11), [12](https://arxiv.org/html/2307.06435v10#bib.bib12), [6](https://arxiv.org/html/2307.06435v10#bib.bib6), [13](https://arxiv.org/html/2307.06435v10#bib.bib13), [14](https://arxiv.org/html/2307.06435v10#bib.bib14), [15](https://arxiv.org/html/2307.06435v10#bib.bib15)\]. An increasing trend in the number of released LLMs and names of a few significant LLMs proposed over the years are shown in Fig [1](https://arxiv.org/html/2307.06435v10#S0.F1 "Figure 1 ‣ A Comprehensive Overview of Large Language Models") and Fig [2](https://arxiv.org/html/2307.06435v10#S0.F2 "Figure 2 ‣ A Comprehensive Overview of Large Language Models"), respectively.  
The early work on LLMs, such as T5 \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\] and mT5 \[[11](https://arxiv.org/html/2307.06435v10#bib.bib11)\] employed transfer learning until GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\] showed LLMs are zero-shot transferable to downstream tasks without fine-tuning. LLMs accurately respond to task queries when prompted with task descriptions and examples. However, pre-trained LLMs fail to follow user intent and perform worse in zero-shot settings than in few-shot. Fine-tuning them with task instructions data \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16), [17](https://arxiv.org/html/2307.06435v10#bib.bib17), [18](https://arxiv.org/html/2307.06435v10#bib.bib18), [19](https://arxiv.org/html/2307.06435v10#bib.bib19)\] and aligning with human preferences \[[20](https://arxiv.org/html/2307.06435v10#bib.bib20), [21](https://arxiv.org/html/2307.06435v10#bib.bib21)\] enhances generalization to unseen tasks, improving zero-shot performance significantly and reducing misaligned behavior.  
In addition to better generalization and domain adaptation, LLMs appear to have emergent abilities, such as reasoning, planning, decision-making, in-context learning, answering in zero-shot settings, etc. These abilities are known to be acquired by them due to their gigantic scale even when the pre-trained LLMs are not trained specifically to possess these attributes \[[22](https://arxiv.org/html/2307.06435v10#bib.bib22), [23](https://arxiv.org/html/2307.06435v10#bib.bib23), [24](https://arxiv.org/html/2307.06435v10#bib.bib24)\]. Such abilities have led LLMs to be widely adopted in diverse settings, including multi-modal, robotics, tool manipulation, question answering, autonomous agents, etc. Various improvements have also been suggested in these areas either by task-specific training \[[25](https://arxiv.org/html/2307.06435v10#bib.bib25), [26](https://arxiv.org/html/2307.06435v10#bib.bib26), [27](https://arxiv.org/html/2307.06435v10#bib.bib27), [28](https://arxiv.org/html/2307.06435v10#bib.bib28), [29](https://arxiv.org/html/2307.06435v10#bib.bib29), [30](https://arxiv.org/html/2307.06435v10#bib.bib30), [31](https://arxiv.org/html/2307.06435v10#bib.bib31)\] or better prompting \[[32](https://arxiv.org/html/2307.06435v10#bib.bib32)\].  

[Image: Refer to caption](extracted/5933067/LLMs_Overview.png)

Figure 3: A broader overview of LLMs, dividing LLMs into seven branches: 1. Pre-Training 2. Fine-Tuning 3. Efficient 4. Inference 5. Evaluation 6. Applications 7. Challenges

The LLMs abilities to solve diverse tasks with human-level performance come at the cost of slow training and inference, extensive hardware requirements, and higher running costs. Such requirements have limited their adoption and opened up opportunities to devise better architectures \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15), [33](https://arxiv.org/html/2307.06435v10#bib.bib33), [34](https://arxiv.org/html/2307.06435v10#bib.bib34), [35](https://arxiv.org/html/2307.06435v10#bib.bib35)\] and training strategies \[[36](https://arxiv.org/html/2307.06435v10#bib.bib36), [37](https://arxiv.org/html/2307.06435v10#bib.bib37), [21](https://arxiv.org/html/2307.06435v10#bib.bib21), [38](https://arxiv.org/html/2307.06435v10#bib.bib38), [39](https://arxiv.org/html/2307.06435v10#bib.bib39), [40](https://arxiv.org/html/2307.06435v10#bib.bib40), [41](https://arxiv.org/html/2307.06435v10#bib.bib41)\]. Parameter efficient tuning \[[38](https://arxiv.org/html/2307.06435v10#bib.bib38), [41](https://arxiv.org/html/2307.06435v10#bib.bib41), [40](https://arxiv.org/html/2307.06435v10#bib.bib40)\], pruning \[[42](https://arxiv.org/html/2307.06435v10#bib.bib42), [43](https://arxiv.org/html/2307.06435v10#bib.bib43)\], quantization \[[44](https://arxiv.org/html/2307.06435v10#bib.bib44), [45](https://arxiv.org/html/2307.06435v10#bib.bib45)\], knowledge distillation, and context length interpolation \[[46](https://arxiv.org/html/2307.06435v10#bib.bib46), [47](https://arxiv.org/html/2307.06435v10#bib.bib47), [48](https://arxiv.org/html/2307.06435v10#bib.bib48), [49](https://arxiv.org/html/2307.06435v10#bib.bib49)\] among others are some of the methods widely studied for efficient LLM utilization.  
Due to the success of LLMs on a wide variety of tasks, the research literature has recently experienced a large influx of LLM-related contributions. Researchers have organized the LLMs literature in surveys \[[50](https://arxiv.org/html/2307.06435v10#bib.bib50), [51](https://arxiv.org/html/2307.06435v10#bib.bib51), [52](https://arxiv.org/html/2307.06435v10#bib.bib52), [53](https://arxiv.org/html/2307.06435v10#bib.bib53)\], and topic-specific surveys in \[[54](https://arxiv.org/html/2307.06435v10#bib.bib54), [55](https://arxiv.org/html/2307.06435v10#bib.bib55), [56](https://arxiv.org/html/2307.06435v10#bib.bib56), [57](https://arxiv.org/html/2307.06435v10#bib.bib57), [58](https://arxiv.org/html/2307.06435v10#bib.bib58)\]. In contrast to these surveys, our contribution focuses on providing a comprehensive yet concise overview of the general direction of LLM research. This article summarizes architectural and training details of pre-trained LLMs and delves deeper into the details of concepts like fine-tuning, multi-modal LLMs, augmented LLMs, datasets, evaluation, applications, challenges, and others to provide a self-contained comprehensive overview. Our key contributions are summarized as follows.

*   1.
    
    We present a survey on the developments in LLM research, providing a concise, comprehensive overview of the direction.
    
*   2.
    
    We present extensive summaries of pre-trained models that include fine-grained details of architecture and training details.
    
*   3.
    
    We summarize major findings of the popular contributions and provide a detailed discussion on the key design and development aspects of LLMs to help practitioners effectively leverage this technology.
    
*   4.
    
    In this self-contained article, we cover a range of concepts to present the general direction of LLMs comprehensively, including background, pre-training, fine-tuning, multi-modal LLMs, augmented LLMs, LLMs-powered agents, datasets, evaluation, etc.
    

We loosely follow the existing terminology to ensure a standardized outlook of this research direction. For instance, following \[[50](https://arxiv.org/html/2307.06435v10#bib.bib50)\], our survey discusses pre-trained LLMs with 10B parameters or more. We refer the readers interested in smaller pre-trained models to \[[51](https://arxiv.org/html/2307.06435v10#bib.bib51), [52](https://arxiv.org/html/2307.06435v10#bib.bib52), [53](https://arxiv.org/html/2307.06435v10#bib.bib53)\].

The organization of this paper is as follows. Section [2](https://arxiv.org/html/2307.06435v10#S2 "2 Background ‣ A Comprehensive Overview of Large Language Models") discusses the background of LLMs. Section [3](https://arxiv.org/html/2307.06435v10#S3 "3 Large Language Models ‣ A Comprehensive Overview of Large Language Models") focuses on LLMs overview, architectures, training pipelines and strategies, fine-tuning, and utilization in different domains. Section [4](https://arxiv.org/html/2307.06435v10#S4 "4 Model Configurations ‣ A Comprehensive Overview of Large Language Models") highlights the configuration and parameters that play a crucial role in the functioning of these models. Summary and discussions are presented in section [3.8](https://arxiv.org/html/2307.06435v10#S3.SS8 "3.8 Summary and Discussion ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"). The LLM training and evaluation, datasets, and benchmarks are discussed in section [5](https://arxiv.org/html/2307.06435v10#S5 "5 Datasets and Evaluation ‣ A Comprehensive Overview of Large Language Models"), followed by challenges and future directions, and conclusion in sections [7](https://arxiv.org/html/2307.06435v10#S7 "7 Challenges and Future Directions ‣ A Comprehensive Overview of Large Language Models") and [8](https://arxiv.org/html/2307.06435v10#S8 "8 Conclusion ‣ A Comprehensive Overview of Large Language Models"), respectively.

## 2 Background

We provide the relevant background to understand the fundamentals related to LLMs in this section. We briefly discuss necessary components in LLMs and refer the readers interested in details to the original works.

### 2.1 Tokenization

Tokenization \[[59](https://arxiv.org/html/2307.06435v10#bib.bib59)\] is an essential pre-processing step in LLM training that parses the text into non-decomposing units called tokens. Tokens can be characters, subwords \[[60](https://arxiv.org/html/2307.06435v10#bib.bib60)\], symbols \[[61](https://arxiv.org/html/2307.06435v10#bib.bib61)\], or words, depending on the tokenization process. Some of the commonly used tokenization schemes in LLMs include wordpiece \[[62](https://arxiv.org/html/2307.06435v10#bib.bib62)\], byte pair encoding (BPE) \[[61](https://arxiv.org/html/2307.06435v10#bib.bib61)\], and unigramLM \[[60](https://arxiv.org/html/2307.06435v10#bib.bib60)\]. Readers are encouraged to refer to \[[63](https://arxiv.org/html/2307.06435v10#bib.bib63)\] for a detailed survey.

### 2.2 Encoding Positions

The transformer processes input sequences in parallel and independently of each other. Moreover, the attention module in the transformer does not capture positional information. As a result, positional encodings were introduced in transformer \[[64](https://arxiv.org/html/2307.06435v10#bib.bib64)\], where a positional embedding vector is added to the token embedding. Variants of positional embedding include absolute, relative, or learned positional encodings. Within relative encoding, Alibi and RoPE are two widely used positional embeddings in LLMs.  
_Alibi \[[65](https://arxiv.org/html/2307.06435v10#bib.bib65)\]:_ It subtracts a scalar bias from the attention score that increases with the distance between token positions. This favors using recent tokens for attention.  
_RoPE \[[66](https://arxiv.org/html/2307.06435v10#bib.bib66)\]:_ It rotates query and key representations at an angle proportional to the token absolute position in the input sequence, resulting in a relative positional encoding scheme which decays with the distance between the tokens.

### 2.3 Attention in LLMs

Attention assigns weights to input tokens based on importance so that the model gives more emphasis to relevant tokens. Attention in transformers \[[64](https://arxiv.org/html/2307.06435v10#bib.bib64)\] calculates query, key, and value mappings for input sequences, where the attention score is obtained by multiplying the query and key, and later used to weight values. We discuss different attention strategies used in LLMs below.  
_Self-Attention \[[64](https://arxiv.org/html/2307.06435v10#bib.bib64)\]:_ Calculates attention using queries, keys, and values from the same block (encoder or decoder).  
_Cross Attention:_ It is used in encoder-decoder architectures, where encoder outputs are the queries, and key-value pairs come from the decoder.  
_Sparse Attention \[[67](https://arxiv.org/html/2307.06435v10#bib.bib67)\]:_ Self-attention has O⁢(n2)𝑂superscript𝑛2O(n^{2})italic\_O ( italic\_n start\_POSTSUPERSCRIPT 2 end\_POSTSUPERSCRIPT ) time complexity which becomes infeasible for large sequences. To speed up the computation, sparse attention \[[67](https://arxiv.org/html/2307.06435v10#bib.bib67)\] iteratively calculates attention in sliding windows for speed gains.  
_Flash Attention \[[68](https://arxiv.org/html/2307.06435v10#bib.bib68)\]:_ Memory access is the major bottleneck in calculating attention using GPUs. To speed up, flash attention employs input tiling to minimize the memory reads and writes between the GPU high bandwidth memory (HBM) and the on-chip SRAM.  

### 2.4 Activation Functions

The activation functions serve a crucial role in the curve-fitting abilities of neural networks \[[69](https://arxiv.org/html/2307.06435v10#bib.bib69)\]. We discuss activation functions used in LLMs in this section.  
_ReLU \[[70](https://arxiv.org/html/2307.06435v10#bib.bib70)\]:_ The Rectified linear unit (ReLU) is defined as:

R⁢e⁢L⁢U⁢(x)\=m⁢a⁢x⁢(0,x)𝑅𝑒𝐿𝑈𝑥𝑚𝑎𝑥0𝑥ReLU(x)=max(0,x)italic\_R italic\_e italic\_L italic\_U ( italic\_x ) = italic\_m italic\_a italic\_x ( 0 , italic\_x )

(1)

_GeLU \[[71](https://arxiv.org/html/2307.06435v10#bib.bib71)\]:_ The Gaussian Error Linear Unit (GeLU) is the combination of ReLU, dropout \[[72](https://arxiv.org/html/2307.06435v10#bib.bib72)\] and zoneout \[[73](https://arxiv.org/html/2307.06435v10#bib.bib73)\].  
_GLU variants \[[74](https://arxiv.org/html/2307.06435v10#bib.bib74)\]:_ The Gated Linear Unit \[[75](https://arxiv.org/html/2307.06435v10#bib.bib75)\] is a neural network layer that is an element-wise product (⊗tensor-product\\otimes⊗) of a linear transformation and a sigmoid transformed (σ𝜎\\sigmaitalic\_σ) linear projection of the input given as:

G⁢L⁢U⁢(x,W,V,b,c)\=(x⁢W+b)⊗σ⁢(x⁢V+c),𝐺𝐿𝑈𝑥𝑊𝑉𝑏𝑐tensor-product𝑥𝑊𝑏𝜎𝑥𝑉𝑐GLU(x,W,V,b,c)=(xW+b)\\otimes\\sigma(xV+c),italic\_G italic\_L italic\_U ( italic\_x , italic\_W , italic\_V , italic\_b , italic\_c ) = ( italic\_x italic\_W + italic\_b ) ⊗ italic\_σ ( italic\_x italic\_V + italic\_c ) ,

(2)

where X𝑋Xitalic\_X is the input of layer and l𝑙litalic\_l, W,b,V⁢ and ⁢c𝑊𝑏𝑉 and 𝑐W,b,V\\textnormal{ and }citalic\_W , italic\_b , italic\_V and italic\_c are learned parameters. Other GLU variants \[[74](https://arxiv.org/html/2307.06435v10#bib.bib74)\] used in LLMs are:

R⁢e⁢G⁢L⁢U⁢(x,W,V,b,c)𝑅𝑒𝐺𝐿𝑈𝑥𝑊𝑉𝑏𝑐\\displaystyle ReGLU(x,W,V,b,c)italic\_R italic\_e italic\_G italic\_L italic\_U ( italic\_x , italic\_W , italic\_V , italic\_b , italic\_c )

\=max(0,xW+b)⊗,\\displaystyle=max(0,xW+b)\\otimes,\= italic\_m italic\_a italic\_x ( 0 , italic\_x italic\_W + italic\_b ) ⊗ ,

G⁢E⁢G⁢L⁢U⁢(x,W,V,b,c)𝐺𝐸𝐺𝐿𝑈𝑥𝑊𝑉𝑏𝑐\\displaystyle GEGLU(x,W,V,b,c)italic\_G italic\_E italic\_G italic\_L italic\_U ( italic\_x , italic\_W , italic\_V , italic\_b , italic\_c )

\=G⁢E⁢L⁢U⁢(x⁢W+b)⊗(x⁢V+c),absenttensor-product𝐺𝐸𝐿𝑈𝑥𝑊𝑏𝑥𝑉𝑐\\displaystyle=GELU(xW+b)\\otimes(xV+c),\= italic\_G italic\_E italic\_L italic\_U ( italic\_x italic\_W + italic\_b ) ⊗ ( italic\_x italic\_V + italic\_c ) ,

S⁢w⁢i⁢G⁢L⁢U⁢(x,W,V,b,c,β)𝑆𝑤𝑖𝐺𝐿𝑈𝑥𝑊𝑉𝑏𝑐𝛽\\displaystyle SwiGLU(x,W,V,b,c,\\beta)italic\_S italic\_w italic\_i italic\_G italic\_L italic\_U ( italic\_x , italic\_W , italic\_V , italic\_b , italic\_c , italic\_β )

\=S⁢w⁢i⁢s⁢h⁢β⁢(x⁢W+b)⊗(x⁢V+c).absenttensor-product𝑆𝑤𝑖𝑠ℎ𝛽𝑥𝑊𝑏𝑥𝑉𝑐\\displaystyle=Swish\\beta(xW+b)\\otimes(xV+c).\= italic\_S italic\_w italic\_i italic\_s italic\_h italic\_β ( italic\_x italic\_W + italic\_b ) ⊗ ( italic\_x italic\_V + italic\_c ) .

### 2.5 Layer Normalization

Layer normalization leads to faster convergence and is an integrated component of transformers \[[64](https://arxiv.org/html/2307.06435v10#bib.bib64)\]. In addition to LayerNorm \[[76](https://arxiv.org/html/2307.06435v10#bib.bib76)\] and RMSNorm \[[77](https://arxiv.org/html/2307.06435v10#bib.bib77)\], LLMs use pre-layer normalization \[[78](https://arxiv.org/html/2307.06435v10#bib.bib78)\], applying it before multi-head attention (MHA). Pre-norm is shown to provide training stability in LLMs. Another normalization variant, DeepNorm \[[79](https://arxiv.org/html/2307.06435v10#bib.bib79)\] fixes the issue with larger gradients in pre-norm.

### 2.6 Distributed LLM Training

This section describes distributed LLM training approaches briefly. More details are available in \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13), [37](https://arxiv.org/html/2307.06435v10#bib.bib37), [80](https://arxiv.org/html/2307.06435v10#bib.bib80), [81](https://arxiv.org/html/2307.06435v10#bib.bib81)\].  
_Data Parallelism:_ Data parallelism replicates the model on multiple devices where data in a batch gets divided across devices. At the end of each training iteration weights are synchronized across all devices.  
_Tensor Parallelism:_ Tensor parallelism shards a tensor computation across devices. It is also known as horizontal parallelism or intra-layer model parallelism.  
_Pipeline Parallelism:_ Pipeline parallelism shards model layers across different devices. This is also known as vertical parallelism.  
_Model Parallelism:_ A combination of tensor and pipeline parallelism is known as model parallelism.  
_3D Parallelism:_ A combination of data, tensor, and model parallelism is known as 3D parallelism.  
_Optimizer Parallelism:_ Optimizer parallelism also known as zero redundancy optimizer \[[37](https://arxiv.org/html/2307.06435v10#bib.bib37)\] implements optimizer state partitioning, gradient partitioning, and parameter partitioning across devices to reduce memory consumption while keeping the communication costs as low as possible.

### 2.7 Libraries

Some commonly used libraries for LLMs training are: _Transformers \[[82](https://arxiv.org/html/2307.06435v10#bib.bib82)\]:_ The library provides access to various pre-trained transformer models with APIs to train, fine-tune, infer, and develop custom models.  
_DeepSpeed \[[36](https://arxiv.org/html/2307.06435v10#bib.bib36)\]:_ A library for scalable distributed training and inference of deep learning models.  
_Megatron-LM \[[80](https://arxiv.org/html/2307.06435v10#bib.bib80)\]:_ It provides GPU-optimized techniques for large-scale training of LLMs.  
_JAX \[[83](https://arxiv.org/html/2307.06435v10#bib.bib83)\]:_ A Python library for high-performance numerical computing and scaleable machine learning. It can differentiate native Python and NumPy functions and execute them on GPUs.  
_Colossal-AI \[[84](https://arxiv.org/html/2307.06435v10#bib.bib84)\]:_ A collection of components to write distributed deep learning models.  
_BMTrain \[[81](https://arxiv.org/html/2307.06435v10#bib.bib81)\]:_ A library to write efficient stand-alone LLMs training code.  
_FastMoE \[[85](https://arxiv.org/html/2307.06435v10#bib.bib85)\]:_ Provides API to build mixture-of-experts (MoE) model in PyTorch.  
_MindSpore \[[86](https://arxiv.org/html/2307.06435v10#bib.bib86)\]:_ A deep learning training and inference framework extendable to mobile, edge, and cloud computing.  
_PyTorch \[[87](https://arxiv.org/html/2307.06435v10#bib.bib87)\]:_ A framework developed by Facebook AI Research lab (FAIR) to build deep learning models. The main features of PyTorch include a dynamic computation graph and a pythonic coding style.  
_Tensorflow \[[88](https://arxiv.org/html/2307.06435v10#bib.bib88)\]:_ A deep learning framework written by Google. The key features of TensorFlow are graph-based computation, eager execution, scalability, etc.  
_MXNet \[[89](https://arxiv.org/html/2307.06435v10#bib.bib89)\]:_ Apache MXNet is a deep learning framework with support to write programs in multiple languages, including, Python, C++, Scala, R, etc. It also provides support for dynamic and static computation graphs.

### 2.8 Data PreProcessing

This section briefly summarizes data preprocessing techniques used in LLMs training.  
_Quality Filtering:_ For better results, training data quality is essential. Some approaches to filtering data are: 1) classifier-based and 2) heuristics-based. Classifier-based approaches train a classifier on high-quality data and predict the quality of text for filtering, whereas heuristics-based employ some rules for filtering like language, metrics, statistics, and keywords.  
_Data Deduplication:_ Duplicated data can affect model performance and increase data memorization; therefore, to train LLMs, data deduplication is one of the preprocessing steps. This can be performed at multiple levels, like sentences, documents, and datasets.  
_Privacy Reduction:_ Most of the training data for LLMs is collected through web sources. This data contains private information; therefore, many LLMs employ heuristics-based methods to filter information such as names, addresses, and phone numbers to avoid learning personal information.  

### 2.9 Architectures

Here we discuss the variants of the transformer architectures used in LLMs. The difference arises due to the application of the attention and the connection of transformer blocks. An illustration of attention patterns of these architectures is shown in Figure [4](https://arxiv.org/html/2307.06435v10#S2.F4 "Figure 4 ‣ 2.9 Architectures ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models").  
_Encoder Decoder:_ This architecture processes inputs through the encoder and passes the intermediate representation to the decoder to generate the output. Here, the encoder sees the complete sequence utilizing self-attention whereas the decoder processes the sequence one after the other with implementing cross-attention.  
_Causal Decoder:_ A type of architecture that does not have an encoder and processes and generates output using a decoder, where the predicted token depends only on the previous time steps.  
_Prefix Decoder:_ It is also known as a non-causal decoder, where the attention calculation is not strictly dependent on the past information and the attention is bidirectional. An example of a non-causal attention mask is shown in Figure [4](https://arxiv.org/html/2307.06435v10#S2.F4 "Figure 4 ‣ 2.9 Architectures ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models").  
_Mixture-of-Experts:_ It is a variant of transformer architecture with parallel independent experts and a router to route tokens to experts. These experts are feed-forward layers after the attention block \[[90](https://arxiv.org/html/2307.06435v10#bib.bib90)\]. Mixture-of-Experts (MoE) is an efficient sparse architecture that offers comparable performance to dense models and allows increasing the model size without increasing the computational cost by activating only a few experts at a time \[[91](https://arxiv.org/html/2307.06435v10#bib.bib91), [92](https://arxiv.org/html/2307.06435v10#bib.bib92)\].

[Image: Refer to caption](extracted/5933067/architectures.png)

Figure 4: An example of attention patterns in language models, image is taken from \[[93](https://arxiv.org/html/2307.06435v10#bib.bib93)\].

[Image: Refer to caption](extracted/5933067/training_objectives.png)

Figure 5: An example of language model training objectives, image from \[[93](https://arxiv.org/html/2307.06435v10#bib.bib93)\].

### 2.10 Pre-Training Objectives

This section describes LLMs pre-training objectives. For more details see the paper \[[93](https://arxiv.org/html/2307.06435v10#bib.bib93)\].

[Image: Refer to caption](extracted/5933067/Flow_diagram_LLMs.png)

Figure 6: A basic flow diagram depicting various stages of LLMs from pre-training to prompting/utilization. Prompting LLMs to generate responses is possible at different training stages like pre-training, instruction-tuning, or alignment tuning. “RL” stands for reinforcement learning, “RM” represents reward-modeling, and “RLHF” represents reinforcement learning with human feedback.

_Full Language Modeling:_ An autoregressive language modeling objective where the model is asked to predict future tokens given the previous tokens, an example is shown in Figure [5](https://arxiv.org/html/2307.06435v10#S2.F5 "Figure 5 ‣ 2.9 Architectures ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models").  
_Prefix Language Modeling:_ A non-causal training objective, where a prefix is chosen randomly and only remaining target tokens are used to calculate the loss. An example is shown in Figure [5](https://arxiv.org/html/2307.06435v10#S2.F5 "Figure 5 ‣ 2.9 Architectures ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models").  
_Masked Language Modeling:_ In this training objective, tokens or spans (a sequence of tokens) are masked randomly and the model is asked to predict masked tokens given the past and future context. An example is shown in Figure [5](https://arxiv.org/html/2307.06435v10#S2.F5 "Figure 5 ‣ 2.9 Architectures ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models").  
_Unified Language Modeling:_ Unified language modeling \[[94](https://arxiv.org/html/2307.06435v10#bib.bib94)\] is a combination of causal, non-causal, and masked language training objectives. Here in masked language modeling, the attention is not bidirectional but unidirectional, attending either left-to-right or right-to-left context.  

### 2.11 LLMs Scaling Laws

Scaling laws study the optimal combination of model parameters, dataset size, and computational resources that predict the improvement in the model performance. It has been shown that the loss scales according to the power-law with model size, dataset size, and compute resources \[[95](https://arxiv.org/html/2307.06435v10#bib.bib95)\]. This study suggests larger models are more important than big data for better performance. Another variant of scaling law \[[96](https://arxiv.org/html/2307.06435v10#bib.bib96)\] suggests the model size and the number of training tokens should be scaled equally.

### 2.12 LLMs Adaptation Stages

This section discusses the fundamentals of LLMs adaptation stages, from pre-training to fine-tuning for downstream tasks and utilization. An example of different training stages and inference in LLMs is shown in Figure [6](https://arxiv.org/html/2307.06435v10#S2.F6 "Figure 6 ‣ 2.10 Pre-Training Objectives ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models"). In this paper, we refer to alignment-tuning as aligning with human preferences, while occasionally the literature uses the term alignment for different purposes.

#### 2.12.1 Pre-Training

In the very first stage, the model is trained in a self-supervised manner on a large corpus to predict the next tokens given the input. The design choices of LLMs vary from encoder-decoder to decoder-only architectures with different building blocks and loss functions in sections [2.5](https://arxiv.org/html/2307.06435v10#S2.SS5 "2.5 Layer Normalization ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models"), [2.4](https://arxiv.org/html/2307.06435v10#S2.SS4 "2.4 Activation Functions ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models"),  [2.10](https://arxiv.org/html/2307.06435v10#S2.SS10 "2.10 Pre-Training Objectives ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models").

#### 2.12.2 Fine-Tuning

There are different styles to fine-tune an LLM. This section briefly discusses fine-tuning approaches.  
  _Transfer Learning:_ The pre-trained LLMs perform well for various tasks \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6), [15](https://arxiv.org/html/2307.06435v10#bib.bib15)\]. However, to improve the performance for a downstream task, pre-trained models are fine-tuned with the task-specific data \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10), [11](https://arxiv.org/html/2307.06435v10#bib.bib11)\], known as transfer learning.  
  _Instruction-tuning:_ To enable a model to respond to user queries effectively, the pre-trained model is fine-tuned on instruction formatted data i.e., instruction and an input-output pair. Instructions generally comprise multi-task data in plain natural language, guiding the model to respond according to the prompt and the input. This type of fine-tuning improves zero-shot generalization and downstream task performance. Details on formatting instruction data and its various styles are available in \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16), [50](https://arxiv.org/html/2307.06435v10#bib.bib50), [97](https://arxiv.org/html/2307.06435v10#bib.bib97)\].  
  _Alignment-tuning:_ LLMs are prone to generating false, biased, and harmful text. To make them helpful, honest, and harmless, models are aligned using human feedback. Alignment involves asking LLMs to generate unexpected responses and then updating their parameters to avoid such responses \[[20](https://arxiv.org/html/2307.06435v10#bib.bib20), [21](https://arxiv.org/html/2307.06435v10#bib.bib21), [98](https://arxiv.org/html/2307.06435v10#bib.bib98)\].  
It ensures LLMs operate according to human intentions and values. A model is defined to be an “aligned” model if the model fulfills three criteria of helpful, honest, and harmless or “HHH” \[[99](https://arxiv.org/html/2307.06435v10#bib.bib99)\].  
Researchers employ reinforcement learning with human feedback (RLHF) \[[100](https://arxiv.org/html/2307.06435v10#bib.bib100)\] for model alignment. In RLHF, a fine-tuned model on demonstrations is further trained with reward modeling (RM) and reinforcement learning (RL), shown in Figure [6](https://arxiv.org/html/2307.06435v10#S2.F6 "Figure 6 ‣ 2.10 Pre-Training Objectives ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models"). Below we briefly discuss RM and RL pipelines in RLHF.

Reward modeling: trains a model to rank generated responses according to human preferences using a classification objective. To train the classifier humans annotate LLMs generated responses based on the HHH criteria.  
Reinforcement learning: in combination with the reward model is used for alignment in the next stage. The previously trained reward model ranks LLM-generated responses into preferred vs. non-preferred, which is used to align the model with proximal policy optimization (PPO). This process repeats iteratively until convergence.

#### 2.12.3 Prompting/Utilization

Prompting is a method to query trained LLMs for generating responses, as illustrated in Figure [6](https://arxiv.org/html/2307.06435v10#S2.F6 "Figure 6 ‣ 2.10 Pre-Training Objectives ‣ 2 Background ‣ A Comprehensive Overview of Large Language Models"). LLMs can be prompted in various prompt setups, where they can be adapted to the instructions without fine-tuning and in other cases with fine-tuning on data containing different prompt styles \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16), [101](https://arxiv.org/html/2307.06435v10#bib.bib101), [102](https://arxiv.org/html/2307.06435v10#bib.bib102)\]. A good guide on prompt engineering is available at \[[32](https://arxiv.org/html/2307.06435v10#bib.bib32)\]. Below, we will discuss various widely used prompt setups.  
 _Zero-Shot Prompting:_ LLMs are zero-shot learners and capable of answering queries never seen before. This style of prompting requires LLMs to answer user questions without seeing any examples in the prompt.  
 _In-context Learning:_ Also known as few-shot learning, here, multiple input-output demonstration pairs are shown to the model to generate the desired response. This adaptation style is also called few-shot learning. A discussion on formatting in-context learning (ICL) templates is available in \[[54](https://arxiv.org/html/2307.06435v10#bib.bib54), [50](https://arxiv.org/html/2307.06435v10#bib.bib50), [18](https://arxiv.org/html/2307.06435v10#bib.bib18), [16](https://arxiv.org/html/2307.06435v10#bib.bib16)\].  
  _Reasoning in LLMs:_ LLMs are zero-shot reasoners and can be provoked to generate answers to logical problems, task planning, critical thinking, etc. with reasoning. Generating reasons is possible only by using different prompting styles, whereas to improve LLMs further on reasoning tasks many methods \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16), [97](https://arxiv.org/html/2307.06435v10#bib.bib97)\] train them on reasoning datasets. We discuss various prompting techniques for reasoning below.  
Chain-of-Thought (CoT): A special case of prompting where demonstrations contain reasoning information aggregated with inputs and outputs so that the model generates outcomes with step-by-step reasoning. More details on CoT prompts are available in \[[55](https://arxiv.org/html/2307.06435v10#bib.bib55), [103](https://arxiv.org/html/2307.06435v10#bib.bib103), [101](https://arxiv.org/html/2307.06435v10#bib.bib101)\].  
Self-Consistency: Improves CoT performance by generating multiple responses and selecting the most frequent answer \[[104](https://arxiv.org/html/2307.06435v10#bib.bib104)\].  
Tree-of-Thought (ToT): Explores multiple reasoning paths with possibilities to look ahead and backtrack for problem-solving \[[105](https://arxiv.org/html/2307.06435v10#bib.bib105)\].  
_Single-Turn Instructions:_ In this prompting setup, LLMs are queried only once with all the relevant information in the prompt. LLMs generate responses by understanding the context either in a zero-shot or few-shot setting.  
_Multi-Turn Instructions:_ Solving a complex task requires multiple interactions with LLMs, where feedback and responses from the other tools are given as input to the LLM for the next rounds. This style of using LLMs in the loop is common in autonomous agents.

## 3 Large Language Models

This section reviews LLMs, briefly describing their architectures, training objectives, pipelines, datasets, and fine-tuning details.

### 3.1 Pre-Trained LLMs

Here, we provide summaries of various well-known pre-trained LLMs with significant discoveries, changing the course of research and development in NLP. These LLMs have considerably improved the performance in NLU and NLG domains, and are widely fine-tuned for downstream tasks. Moreover, We also identify key findings and insights of pre-trained LLMs in Table [1](https://arxiv.org/html/2307.06435v10#S3.T1 "Table 1 ‣ 3.1.5 Finance ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models") and [2](https://arxiv.org/html/2307.06435v10#S3.T2 "Table 2 ‣ 3.1.5 Finance ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models") that improve their performance.

#### 3.1.1 General Purpose

 _T5 \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\]:_ An encoder-decoder model employing a unified text-to-text training for all NLP problems is shown in Figure [7](https://arxiv.org/html/2307.06435v10#S3.F7 "Figure 7 ‣ 3.1.1 General Purpose ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"). T5 places layer normalization outside the residual path in a conventional transformer model \[[64](https://arxiv.org/html/2307.06435v10#bib.bib64)\]. It uses masked language modeling as a pre-training objective where spans (consecutive tokens) are replaced with a single mask instead of separate masks for each token. This type of masking speeds up the training as it produces shorter sequences. After pre-training, the model is fine-tuned using adapter layers \[[106](https://arxiv.org/html/2307.06435v10#bib.bib106)\] for downstream tasks.

[Image: Refer to caption](extracted/5933067/T5.png)

Figure 7: Unified text-to-text training example, source image from \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\].

 _GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\]:_ The GPT-3 architecture is the same as the GPT-2 \[[5](https://arxiv.org/html/2307.06435v10#bib.bib5)\] but with dense and sparse attention in transformer layers similar to the Sparse Transformer \[[67](https://arxiv.org/html/2307.06435v10#bib.bib67)\]. It shows that large models can train on larger batch sizes with a lower learning rate to decide the batch size during training, GPT-3 uses the gradient noise scale as in  \[[107](https://arxiv.org/html/2307.06435v10#bib.bib107)\]. Overall, GPT-3 increases model parameters to 175B showing that the performance of large language models improves with the scale and is competitive with the fine-tuned models.

 _mT5 \[[11](https://arxiv.org/html/2307.06435v10#bib.bib11)\]:_ A multilingual T5 model \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\] trained on the mC4 dataset with 101 languages. The dataset is extracted from the public common crawl scrape. The model uses a larger vocabulary size of 250,000 to cover multiple languages. To avoid over-fitting or under-fitting for a language, mT5 employs a data sampling procedure to select samples from all languages. The paper suggests using a small amount of pre-training datasets, including all languages when fine-tuning for a task using English language data. This allows the model to generate correct non-English outputs.

 _PanGu-αα\\alphaitalic\_α \[[108](https://arxiv.org/html/2307.06435v10#bib.bib108)\]:_ An autoregressive model that has a query layer at the end of standard transformer layers, example shown in Figure [8](https://arxiv.org/html/2307.06435v10#S3.F8 "Figure 8 ‣ 3.1.1 General Purpose ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"), to predict the next token. Its structure is similar to the transformer layer but with an additional embedding for the next position in the attention mechanism, given in Eq. [3](https://arxiv.org/html/2307.06435v10#S3.E3 "In 3.1.1 General Purpose ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models").

a\=pn⁢Whq⁢Whk⁢T⁢HLT𝑎subscript𝑝𝑛superscriptsubscript𝑊ℎ𝑞superscriptsubscript𝑊ℎ𝑘𝑇superscriptsubscript𝐻𝐿𝑇a=p\_{n}W\_{h}^{q}W\_{h}^{k}TH\_{L}^{T}italic\_a = italic\_p start\_POSTSUBSCRIPT italic\_n end\_POSTSUBSCRIPT italic\_W start\_POSTSUBSCRIPT italic\_h end\_POSTSUBSCRIPT start\_POSTSUPERSCRIPT italic\_q end\_POSTSUPERSCRIPT italic\_W start\_POSTSUBSCRIPT italic\_h end\_POSTSUBSCRIPT start\_POSTSUPERSCRIPT italic\_k end\_POSTSUPERSCRIPT italic\_T italic\_H start\_POSTSUBSCRIPT italic\_L end\_POSTSUBSCRIPT start\_POSTSUPERSCRIPT italic\_T end\_POSTSUPERSCRIPT

(3)

[Image: Refer to caption](extracted/5933067/PanGU_alpha.png)

Figure 8: The image is the article of \[[108](https://arxiv.org/html/2307.06435v10#bib.bib108)\], showing an example of PanGu-α𝛼\\alphaitalic\_α architecture.

 _CPM-2 \[[12](https://arxiv.org/html/2307.06435v10#bib.bib12)\]:_ Cost-efficient Pre-trained language Models (CPM-2) pre-trains bilingual (English and Chinese) 11B and 198B mixture-of-experts (MoE) models on the WuDaoCorpus \[[109](https://arxiv.org/html/2307.06435v10#bib.bib109)\] dataset. The tokenization process removes “\_” white space tokens in the sentencepiece tokenizer. The models are trained with knowledge inheritance, starting with only the Chinese language in the first stage and then adding English and Chinese data. This trained model gets duplicated multiple times to initialize the 198B MoE model. Moreover, to use the model for downstream tasks, CPM-2 experimented with both complete fine-tuning and prompt fine-tuning as in \[[40](https://arxiv.org/html/2307.06435v10#bib.bib40)\] where only prompt-related parameters are updated by inserting prompts at various positions, front, middle, and back. CPM-2 also proposes the INFMOE, a memory-efficient framework with a strategy to dynamically offload parameters to the CPU for inference at a 100B scale. It overlaps data movement with inference computation for lower inference time.

 _ERNIE 3.0 \[[110](https://arxiv.org/html/2307.06435v10#bib.bib110)\]:_ ERNIE 3.0 takes inspiration from multi-task learning to build a modular architecture using Transformer-XL \[[111](https://arxiv.org/html/2307.06435v10#bib.bib111)\] as the backbone. The universal representation module is shared by all the tasks, which serve as the basic block for task-specific representation modules, which are all trained jointly for natural language understanding, natural language generation, and knowledge extraction. This LLM is primarily focused on the Chinese language. It claims to train on the largest Chinese text corpora for LLM training, and achieved state-of-the-art in 54 Chinese NLP tasks.

 _Jurassic-1 \[[112](https://arxiv.org/html/2307.06435v10#bib.bib112)\]:_ A pair of auto-regressive language models, including a 7B-parameter J1-Large model and a 178B-parameter J1-Jumbo model. The training vocabulary of Jurassic-1 comprise word pieces, complete words, and multi-word expressions without any word boundaries, where possible out-of-vocabulary instances are interpreted as Unicode bytes. Compared to the GPT-3 counterparts, the Jurassic-1 models apply a more balanced depth-to-width self-attention architecture \[[113](https://arxiv.org/html/2307.06435v10#bib.bib113)\] and an improved tokenizer for a faster prediction based on broader resources, achieving a comparable performance in zero-shot learning tasks and a superior performance in few-shot learning tasks given the ability to feed more examples as a prompt.

 _HyperCLOVA \[[114](https://arxiv.org/html/2307.06435v10#bib.bib114)\]:_ A Korean language model with GPT-3 architecture.

 _Yuan 1.0 \[[115](https://arxiv.org/html/2307.06435v10#bib.bib115)\]:_ Trained on a Chinese corpus with 5TB of high-quality text collected from the Internet. A Massive Data Filtering System (MDFS) built on Spark is developed to process the raw data via coarse and fine filtering techniques. To speed up the training of Yuan 1.0 to save energy expenses and carbon emissions, various factors that improve the performance of distributed training are incorporated in architecture and training: like increasing the hidden state size improves pipeline and tensor parallelism performance, larger micro batches improve pipeline parallelism performance, and larger global batch size improve data parallelism performance. In practice, the Yuan 1.0 model performs well on text classification, Winograd Schema, natural language inference, and reading comprehension tasks.

 _Gopher \[[116](https://arxiv.org/html/2307.06435v10#bib.bib116)\]:_ The Gopher family of models ranges from 44M to 280B parameters in size to study the effect of scale on the LLMs performance. The 280B model beats GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\], Jurrasic-1 \[[112](https://arxiv.org/html/2307.06435v10#bib.bib112)\], MT-NLG \[[117](https://arxiv.org/html/2307.06435v10#bib.bib117)\], and others on 81% of the evaluated tasks.

 _ERNIE 3.0 TITAN \[[35](https://arxiv.org/html/2307.06435v10#bib.bib35)\]:_ ERNIE 3.0 Titan extends ERNIE 3.0 by training a larger model with 26x the number of parameters of the latter. This bigger model outperformed other state-of-the-art models in 68 NLP tasks. LLMs produce text with incorrect facts. In order to have control of the generated text with factual consistency, ERNIE 3.0 Titan adds another task, Credible and Controllable Generations, to its multi-task learning setup. It introduces additional self-supervised adversarial and controllable language modeling losses to the pre-training step, which enables ERNIE 3.0 Titan to beat other LLMs in their manually selected Factual QA task set evaluations.

 _GPT-NeoX-20B \[[118](https://arxiv.org/html/2307.06435v10#bib.bib118)\]:_ An auto-regressive model that largely follows GPT-3 with a few deviations in architecture design, trained on the Pile dataset without any data deduplication. GPT-NeoX has parallel attention and feed-forward layers in a transformer block, given in Eq. [4](https://arxiv.org/html/2307.06435v10#S3.E4 "In 3.1.1 General Purpose ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"), that increases throughput by 15%. It uses rotary positional embedding \[[66](https://arxiv.org/html/2307.06435v10#bib.bib66)\], applying it to only 25% of embedding vector dimension as in \[[119](https://arxiv.org/html/2307.06435v10#bib.bib119)\]. This reduces the computation without performance degradation. As opposed to GPT-3, which uses dense and sparse layers, GPT-NeoX-20B uses only dense layers. The hyperparameter tuning at this scale is difficult; therefore, the model chooses hyperparameters from the method \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\] and interpolates values between 13B and 175B models for the 20B model. The model training is distributed among GPUs using both tensor and pipeline parallelism.

x+A⁢t⁢t⁢n⁢(L⁢N1⁢(x))+F⁢F⁢(L⁢N2⁢(x))𝑥𝐴𝑡𝑡𝑛𝐿subscript𝑁1𝑥𝐹𝐹𝐿subscript𝑁2𝑥x+Attn(LN\_{1}(x))+FF(LN\_{2}(x))italic\_x + italic\_A italic\_t italic\_t italic\_n ( italic\_L italic\_N start\_POSTSUBSCRIPT 1 end\_POSTSUBSCRIPT ( italic\_x ) ) + italic\_F italic\_F ( italic\_L italic\_N start\_POSTSUBSCRIPT 2 end\_POSTSUBSCRIPT ( italic\_x ) )

(4)

 _OPT \[[14](https://arxiv.org/html/2307.06435v10#bib.bib14)\]:_ It is a clone of GPT-3, developed to open-source a model that replicates GPT-3 performance. Training of OPT employs dynamic loss scaling  \[[120](https://arxiv.org/html/2307.06435v10#bib.bib120)\] and restarts from an earlier checkpoint with a lower learning rate whenever loss divergence is observed. Overall, the performance of OPT-175B models is comparable to the GPT3-175B model.

 _BLOOM \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\]:_ A causal decoder model trained on the ROOTS corpus to open-source an LLM. The architecture of BLOOM is shown in Figure [9](https://arxiv.org/html/2307.06435v10#S3.F9 "Figure 9 ‣ 3.1.1 General Purpose ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"), with differences like ALiBi positional embedding, an additional normalization layer after the embedding layer as suggested by the bitsandbytes111https://github.com/TimDettmers/bitsandbytes library. These changes stabilize training with improved downstream performance.

 _GLaM \[[91](https://arxiv.org/html/2307.06435v10#bib.bib91)\]:_ Generalist Language Model (GLaM) represents a family of language models using a sparsely activated decoder-only mixture-of-experts (MoE) structure \[[121](https://arxiv.org/html/2307.06435v10#bib.bib121), [90](https://arxiv.org/html/2307.06435v10#bib.bib90)\]. To gain more model capacity while reducing computation, the experts are sparsely activated where only the best two experts are used to process each input token. The largest GLaM model, GLaM (64B/64E), is about 7×\\times× larger than GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\], while only part of the parameters are activated per input token. The largest GLaM (64B/64E) model achieves better overall results as compared to GPT-3 while consuming only one-third of GPT-3’s training energy.

[Image: Refer to caption](extracted/5933067/BLOOM.png)

Figure 9: The BLOOM architecture example sourced from \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\].

 _MT-NLG \[[117](https://arxiv.org/html/2307.06435v10#bib.bib117)\]:_ A 530B causal decoder based on the GPT-2 architecture that has roughly 3×\\times× GPT-3 model parameters. MT-NLG is trained on filtered high-quality data collected from various public datasets and blends various types of datasets in a single batch, which beats GPT-3 on several evaluations.

 _Chinchilla \[[96](https://arxiv.org/html/2307.06435v10#bib.bib96)\]:_ A causal decoder trained on the same dataset as the Gopher \[[116](https://arxiv.org/html/2307.06435v10#bib.bib116)\] but with a little different data sampling distribution (sampled from MassiveText). The model architecture is similar to the one used for Gopher, with the exception of AdamW optimizer instead of Adam. Chinchilla identifies the relationship that model size should be doubled for every doubling of training tokens. Over 400 language models ranging from 70 million to over 16 billion parameters on 5 to 500 billion tokens are trained to get the estimates for compute-optimal training under a given budget. The authors train a 70B model with the same compute budget as Gopher (280B) but with 4 times more data. It outperforms Gopher \[[116](https://arxiv.org/html/2307.06435v10#bib.bib116)\], GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\], and others on various downstream tasks, after fine-tuning.

 _AlexaTM \[[122](https://arxiv.org/html/2307.06435v10#bib.bib122)\]:_ An encoder-decoder model, where encoder weights and decoder embeddings are initialized with a pre-trained encoder to speed up training. The encoder stays frozen for the initial 100k steps and is later unfrozen for end-to-end training. The model is trained on a combination of denoising and causal language modeling (CLM) objectives, concatenating a \[C⁢L⁢M\]delimited-\[\]𝐶𝐿𝑀\[CLM\]\[ italic\_C italic\_L italic\_M \] token at the beginning for mode switching. During training, the CLM task is applied for 20% of the time, which improves the in-context learning performance.

 _PaLM \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15)\]:_ A causal decoder with parallel attention and feed-forward layers similar to Eq. [4](https://arxiv.org/html/2307.06435v10#S3.E4 "In 3.1.1 General Purpose ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"), speeding up training by a factor of 15. Additional changes to the conventional transformer model include SwiGLU activation, RoPE embeddings, multi-query attention that saves computation cost during decoding, and shared input-output embeddings. During training, loss spiking was observed, and to fix it, model training was restarted from a 100-step earlier checkpoint by skipping 200-500 batches around the spike. Moreover, the model was found to memorize around 2.4% of the training data at the 540B model scale, whereas this number was lower for smaller models.

 _PaLM-2 \[[123](https://arxiv.org/html/2307.06435v10#bib.bib123)\]:_ A smaller multi-lingual variant of PaLM, trained for larger iterations on a better quality dataset. PaLM-2 shows significant improvements over PaLM, while reducing training and inference costs due to its smaller size. To lessen toxicity and memorization, it appends special tokens with a fraction of pre-training data, which shows a reduction in generating harmful responses.

 _U-PaLM \[[124](https://arxiv.org/html/2307.06435v10#bib.bib124)\]:_ This method trains PaLM for 0.1% additional compute with the UL2 (also named as UL2Restore) objective \[[125](https://arxiv.org/html/2307.06435v10#bib.bib125)\], using the same dataset it outperforms the baseline significantly on various NLP tasks, including zero-shot, few-shot, commonsense reasoning, CoT, etc. Training with UL2R involves converting a causal decoder PaLM to a non-causal decoder PaLM and employing 50% sequential denoising, 25% regular denoising, and 25% extreme denoising loss functions.

 _UL2 \[[125](https://arxiv.org/html/2307.06435v10#bib.bib125)\]:_ An encoder-decoder architecture trained using a mixture of denoisers (MoD) objective. Denoisers include 1) R-Denoiser: a regular span masking, 2) S-Denoiser: which corrupts consecutive tokens of a large sequence and 3) X-Denoiser: which corrupts a large number of tokens randomly. During pre-training, UL2 includes a denoiser token from R,S,X𝑅𝑆𝑋{R,S,X}italic\_R , italic\_S , italic\_X to represent a denoising setup. It helps improve fine-tuning performance for downstream tasks that bind the task to one of the upstream training modes. This MoD style of training outperforms the T5 model on many benchmarks.

 _GLM-130B \[[33](https://arxiv.org/html/2307.06435v10#bib.bib33)\]:_ GLM-130B is a bilingual (English and Chinese) model trained using an auto-regressive mask infilling pre-training objective similar to the GLM \[[126](https://arxiv.org/html/2307.06435v10#bib.bib126)\]. This training style makes the model bidirectional as compared to GPT-3, which is unidirectional. As opposed to GLM, the training of GLM-130B includes a small amount of multi-task instruction pre-training data (5% of the total data) along with self-supervised mask infilling. To stabilize the training, it applies embedding layer gradient shrink.

 _LLaMA \[[127](https://arxiv.org/html/2307.06435v10#bib.bib127), [21](https://arxiv.org/html/2307.06435v10#bib.bib21)\]:_ A set of decoder-only language models varying from 7B to 70B parameters. LLaMA models series is the most famous among the community for parameter efficiency and instruction tuning.

 _LLaMA-1 \[[127](https://arxiv.org/html/2307.06435v10#bib.bib127)\]:_ Implements efficient causal attention \[[128](https://arxiv.org/html/2307.06435v10#bib.bib128)\] by not storing and computing masked attention weights and key/query scores. Another optimization is reducing the number of activations recomputed in the backward pass, as in  \[[129](https://arxiv.org/html/2307.06435v10#bib.bib129)\].

 _LLaMA-2 \[[21](https://arxiv.org/html/2307.06435v10#bib.bib21)\]:_ This work is more focused on fine-tuning a safer and better LLaMA-2-Chat model for dialogue generation. The pre-trained model has 40% more training data with a larger context length and grouped-query attention.

 _LLaMA-3/3.1 \[[130](https://arxiv.org/html/2307.06435v10#bib.bib130)\]:_ A collection of models trained on a seven times larger dataset as compared to LLaMA-2 with double the context length, outperforming its previous variants and other models.

 _PanGu-ΣΣ\\Sigmaroman\_Σ \[[92](https://arxiv.org/html/2307.06435v10#bib.bib92)\]:_ An autoregressive model with parameters copied from PanGu-α𝛼\\alphaitalic\_α and extended to a trillion scale with Random Routed Experts (RRE), the architectural diagram is shown in Figure [10](https://arxiv.org/html/2307.06435v10#S3.F10 "Figure 10 ‣ 3.1.5 Finance ‣ 3.1 Pre-Trained LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"). RRE is similar to the MoE architecture, with distinctions at the second level, where tokens are randomly routed to experts in a domain instead of using a learnable gating method. The model has bottom layers densely activated and shared across all domains, whereas top layers are sparsely activated according to the domain. This training style allows for extracting task-specific models and reduces catastrophic forgetting effects in the case of continual learning.

 _Mixtral8x22b \[[131](https://arxiv.org/html/2307.06435v10#bib.bib131)\]:_ A mixture-of-experts (MoE) model with eight distinct experts routes each token to two experts at each layer and combines the outputs additively.

 _Snowflake Arctic \[[132](https://arxiv.org/html/2307.06435v10#bib.bib132)\]:_ Arctic LLM is a hybrid of dense and mixture-of-experts (MoE) architecture. The MoE (128×\\times×3.66B MLP experts) is parallel to the dense transformer (10B) with only two experts activated. The model has many experts, compared to other MoE LLMs \[[131](https://arxiv.org/html/2307.06435v10#bib.bib131), [133](https://arxiv.org/html/2307.06435v10#bib.bib133)\], to increase the model capacity and provide an opportunity to choose among many experts for a diverse configuration. The model has 480B parameters, and only 17B are active during a forward pass, reducing the computation significantly.

 _Grok \[[133](https://arxiv.org/html/2307.06435v10#bib.bib133), [134](https://arxiv.org/html/2307.06435v10#bib.bib134)\]:_ Grok is a family of LLMs including Grok-1 and Grok-1.5, released by XAI.

 _Grok-1 \[[133](https://arxiv.org/html/2307.06435v10#bib.bib133)\]:_ Grok-1 is a 314B parameters language MoE model (eight experts), where two experts are activated per token.

 _Grok-1.5 \[[134](https://arxiv.org/html/2307.06435v10#bib.bib134)\]:_ Grok-1.5 is a multi-modal LLM with a larger context length and improved performance.

 _Gemini \[[135](https://arxiv.org/html/2307.06435v10#bib.bib135), [136](https://arxiv.org/html/2307.06435v10#bib.bib136)\]:_ Gemini replaces Bard (based on PaLM) with multi-modal capabilities and significant language modeling performance improvements.

 _Gemini-1 \[[135](https://arxiv.org/html/2307.06435v10#bib.bib135)\]:_ The first-ever auto-regressive model to achieve human-level capabilities on the MMLU benchmark.

 _Gemini-1.5 \[[136](https://arxiv.org/html/2307.06435v10#bib.bib136)\]:_ A multi-modal LLM with MoE architecture builds on the findings of Gemini-1. The model has a 2M context window and can reason over information up to 10M tokens. Such large context windows were never achieved previously and shown to have a huge impact on performance gain.

 _Nemotron-4 340B \[[137](https://arxiv.org/html/2307.06435v10#bib.bib137)\]:_ A decoder-only model that has been aligned on 98% synthetic data and only 2% manually annotated data. Utilizing synthetic data at a large proportion improves the model performance significantly. The paper suggested introducing alignment data with a smaller subset of previously seen data during the late stage of the model pre-training, enabling the smooth transition from the pre-trained stage to the final training stage. To train better instruction-following models, weaker models are trained into stronger models iteratively. The synthetic data generated by the weaker instruction-tuned model is used to train a base model which is later supervised fine-tuned outperforming the weaker model.

 _DeepSeek \[[138](https://arxiv.org/html/2307.06435v10#bib.bib138)\]:_ DeepSeek studies the LLMs scaling laws in detail to determine the optimal non-embedding model size and training data. The experiments were performed for 8 budgets ranging from 1e17 to 3e20 training FLOPs. Each compute budget was tested against ten different models/data scales. The batch size and learning rates were also fitted for the given compute budget finding that the batch size should increase with the increased compute budget while decreasing the learning rate. Following are the equations for the optimal batch-size (B𝐵Bitalic\_B), learning rate (η𝜂\\etaitalic\_η), model size (M𝑀Mitalic\_M), and data (D𝐷Ditalic\_D):

Bo⁢p⁢t\=0.2920.C0.3271ηo⁢p⁢t\=0.3118.C−0.1250Mo⁢p⁢t\=Mb⁢a⁢s⁢e.CaDo⁢p⁢t\=Db⁢a⁢s⁢e.CbMb⁢a⁢s⁢e\=0.1715,Db⁢a⁢s⁢e\=5.8316,a\=0.5243,b\=0.4757formulae-sequencesubscript𝐵𝑜𝑝𝑡0.2920superscript𝐶0.3271subscript𝜂𝑜𝑝𝑡0.3118superscript𝐶0.1250subscript𝑀𝑜𝑝𝑡subscript𝑀𝑏𝑎𝑠𝑒superscript𝐶𝑎subscript𝐷𝑜𝑝𝑡subscript𝐷𝑏𝑎𝑠𝑒formulae-sequencesuperscript𝐶𝑏subscript𝑀𝑏𝑎𝑠𝑒0.1715formulae-sequencesubscript𝐷𝑏𝑎𝑠𝑒5.8316formulae-sequence𝑎0.5243𝑏0.4757\\begin{gathered}B\_{opt}=0.2920.C^{0.3271}\\\\ \\eta\_{opt}=0.3118.C^{-0.1250}\\\\ M\_{opt}=M\_{base}.C^{a}\\\\ D\_{opt}=D\_{base}.C^{b}\\\\ M\_{base}=0.1715,D\_{base}=5.8316,a=0.5243,b=0.4757\\\\ \\end{gathered}start\_ROW start\_CELL italic\_B start\_POSTSUBSCRIPT italic\_o italic\_p italic\_t end\_POSTSUBSCRIPT = 0.2920 . italic\_C start\_POSTSUPERSCRIPT 0.3271 end\_POSTSUPERSCRIPT end\_CELL end\_ROW start\_ROW start\_CELL italic\_η start\_POSTSUBSCRIPT italic\_o italic\_p italic\_t end\_POSTSUBSCRIPT = 0.3118 . italic\_C start\_POSTSUPERSCRIPT - 0.1250 end\_POSTSUPERSCRIPT end\_CELL end\_ROW start\_ROW start\_CELL italic\_M start\_POSTSUBSCRIPT italic\_o italic\_p italic\_t end\_POSTSUBSCRIPT = italic\_M start\_POSTSUBSCRIPT italic\_b italic\_a italic\_s italic\_e end\_POSTSUBSCRIPT . italic\_C start\_POSTSUPERSCRIPT italic\_a end\_POSTSUPERSCRIPT end\_CELL end\_ROW start\_ROW start\_CELL italic\_D start\_POSTSUBSCRIPT italic\_o italic\_p italic\_t end\_POSTSUBSCRIPT = italic\_D start\_POSTSUBSCRIPT italic\_b italic\_a italic\_s italic\_e end\_POSTSUBSCRIPT . italic\_C start\_POSTSUPERSCRIPT italic\_b end\_POSTSUPERSCRIPT end\_CELL end\_ROW start\_ROW start\_CELL italic\_M start\_POSTSUBSCRIPT italic\_b italic\_a italic\_s italic\_e end\_POSTSUBSCRIPT = 0.1715 , italic\_D start\_POSTSUBSCRIPT italic\_b italic\_a italic\_s italic\_e end\_POSTSUBSCRIPT = 5.8316 , italic\_a = 0.5243 , italic\_b = 0.4757 end\_CELL end\_ROW

(5)

 _DeepSeek-v2 \[[139](https://arxiv.org/html/2307.06435v10#bib.bib139)\]:_ An MoE model that introduces multi-head latent attention (MLA) to reduce inference costs, by compressing Key-Value (KV) cache into a latent vector. MLA achieves better performance than multi-head attention (MHA), and other efficient attention mechanisms such as grouped query attention (GQA), multi-query attention (MQA), etc. Because of MLA, DeepSeek-v2 achieves 5.76 times faster inference throughput as compared to DeepSeek \[[138](https://arxiv.org/html/2307.06435v10#bib.bib138)\].

#### 3.1.2 Coding

 _CodeGen \[[140](https://arxiv.org/html/2307.06435v10#bib.bib140)\]:_ CodeGen has a similar architecture to PaLM \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15)\], i.e., parallel attention, MLP layers, and RoPE embeddings. The model is trained on both natural language and programming language data sequentially (trained on the first dataset, then the second, and so on) on the following datasets 1) PILE, 2) BIGQUERY, and 3) BIGPYTHON. CodeGen proposed a multi-step approach to synthesizing code. The purpose is to simplify the generation of long sequences where the previous prompt and generated code are given as input with the next prompt to generate the next code sequence. CodeGen opensource a Multi-Turn Programming Benchmark (MTPB) to evaluate multi-step program synthesis.

 _Codex \[[141](https://arxiv.org/html/2307.06435v10#bib.bib141)\]:_ This LLM is trained on a subset of public Python Github repositories to generate code from docstrings. Computer programming is an iterative process where the programs are often debugged and updated before fulfilling the requirements. Similarly, Codex generates 100 versions of a program by repetitive sampling for a given description, which produces a working solution for 77.5% of the problems passing unit tests. Its powerful version powers Github Copilot222https://github.com/features/copilot.

 _AlphaCode \[[142](https://arxiv.org/html/2307.06435v10#bib.bib142)\]:_ A set of large language models, ranging from 300M to 41B parameters, designed for competition-level code generation tasks. It uses the multi-query attention \[[143](https://arxiv.org/html/2307.06435v10#bib.bib143)\] to reduce memory and cache costs. Since competitive programming problems highly require deep reasoning and an understanding of complex natural language algorithms, the AlphaCode models are pre-trained on filtered GitHub code in popular languages and then fine-tuned on a new competitive programming dataset named CodeContests. The CodeContests dataset mainly contains problems, solutions, and test cases collected from the Codeforces platform333https://codeforces.com/. The pre-training employs standard language modeling objectives, while GOLD \[[144](https://arxiv.org/html/2307.06435v10#bib.bib144)\] with tempering \[[145](https://arxiv.org/html/2307.06435v10#bib.bib145)\] serves as the training objective for the fine-tuning on CodeContests data. To evaluate the performance of AlphaCode, simulated programming competitions are hosted on the Codeforces platform: overall, AlphaCode ranks at the top 54.3% among over 5000 competitors, where its Codeforces rating is within the top 28% of recently participated users.

 _CodeT5+ \[[34](https://arxiv.org/html/2307.06435v10#bib.bib34)\]:_ CodeT5+ is based on CodeT5 \[[146](https://arxiv.org/html/2307.06435v10#bib.bib146)\], with shallow encoder and deep decoder, trained in multiple stages initially unimodal data (code) and later bimodal data (text-code pairs). Each training stage has different training objectives and activates different model blocks encoder, decoder, or both according to the task. The unimodal pre-training includes span denoising and CLM objectives, whereas bimodal pre-training objectives contain contrastive learning, matching, and CLM for text-code pairs. CodeT5+ adds special tokens with the text to enable task modes, for example, \[C⁢L⁢S\]delimited-\[\]𝐶𝐿𝑆\[CLS\]\[ italic\_C italic\_L italic\_S \] for contrastive loss, \[M⁢a⁢t⁢c⁢h\]delimited-\[\]𝑀𝑎𝑡𝑐ℎ\[Match\]\[ italic\_M italic\_a italic\_t italic\_c italic\_h \] for text-code matching, etc.

 _StarCoder \[[147](https://arxiv.org/html/2307.06435v10#bib.bib147)\]:_ A decoder-only model with the SantaCoder architecture, employing Flash attention to scale up the context length to 8k. The StarCoder trains an encoder to filter names, emails, and other personal data from the training data. Its fine-tuned variant outperforms PaLM, LLaMA, and LAMDA on HumanEval and MBPP benchmarks.

#### 3.1.3 Scientific Knowledge

 _Galactica \[[148](https://arxiv.org/html/2307.06435v10#bib.bib148)\]:_ A large curated corpus of human scientific knowledge with 48 million papers, textbooks, lecture notes, millions of compounds and proteins, scientific websites, encyclopedias, and more are trained using the metaseq library3, which is built on PyTorch and fairscale \[[149](https://arxiv.org/html/2307.06435v10#bib.bib149)\]. The model wraps reasoning datasets with the <w⁢o⁢r⁢k\>expectation𝑤𝑜𝑟𝑘<work>< italic\_w italic\_o italic\_r italic\_k > token to provide step-by-step reasoning context to the model, which has been shown to improve the performance on reasoning tasks.

#### 3.1.4 Dialog

 _LaMDA \[[150](https://arxiv.org/html/2307.06435v10#bib.bib150)\]:_ A decoder-only model pre-trained on public dialog data, public dialog utterances, and public web documents, where more than 90% of the pre-training data is in English. LaMDA is trained with the objective of producing responses that exhibit high levels of quality, safety, and groundedness. To achieve this, discriminative and generative fine-tuning techniques are incorporated to enhance the model’s safety and quality aspects. As a result, the LaMDA models can be utilized as a general language model performing various tasks.

#### 3.1.5 Finance

 _BloombergGPT \[[151](https://arxiv.org/html/2307.06435v10#bib.bib151)\]:_ A non-causal decoder model trained using both financial (“FINPILE” from the Bloomberg archive) and general-purpose datasets. The model’s architecture is similar to the BLOOM \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\] and OPT \[[14](https://arxiv.org/html/2307.06435v10#bib.bib14)\]. It allocates 50B parameters to different blocks of the model using the approach \[[113](https://arxiv.org/html/2307.06435v10#bib.bib113)\]. For effective training, BloombergGPT packs documents together with <|e⁢n⁢d⁢o⁢f⁢t⁢e⁢x⁢t|\>absent𝑒𝑛𝑑𝑜𝑓𝑡𝑒𝑥𝑡absent<|endoftext|>< | italic\_e italic\_n italic\_d italic\_o italic\_f italic\_t italic\_e italic\_x italic\_t | > to use the maximum sequence length, uses warmup batch size starting from 1024 to 2048, and manually reduces the learning rate multiple times during the training.

 _Xuan Yuan 2.0 \[[152](https://arxiv.org/html/2307.06435v10#bib.bib152)\]:_ A Chinese financial chat model with BLOOM’s \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\] architecture trained on a combination of general purpose, financial, general purpose instructions, and financial institutions datasets. Xuan Yuan 2.0 combined the pre-training and fine-tuning stages to avoid catastrophic forgetting.

[Image: Refer to caption](extracted/5933067/pangu_sigma.png)

Figure 10: This example illustrates the PanGu-∑\\sum∑ architecture, as depicted in the image sourced from \[[92](https://arxiv.org/html/2307.06435v10#bib.bib92)\].

Table 1: Noteworthy findings and insights of _pre-trained_ Large Language Models.

\\rowcolorgray!50 Models

Findings & Insights

T5

1. Encoder and decoder with shared parameters perform equivalently when parameters are not shared 2. Fine-tuning model layers (adapter layers) work better than the conventional way of training on only classification layers

GPT-3

1. Few-shot performance of LLMs is better than the zero-shot, suggesting that LLMs are meta-learners

mT5

1. Large multi-lingual models perform equivalently to single language models on downstream tasks. However, smaller multi-lingual models perform worse

PanGu-α𝛼\\alphaitalic\_α

1. LLMs have good few shot capabilities

CPM-2

1. Prompt fine-tuning requires updating very few parameters while achieving performance comparable to full model fine-tuning 2. Prompt fine-tuning takes more time to converge as compared to full model fine-tuning 3. Inserting prompt tokens in-between sentences can allow the model to understand relations between sentences and long sequences 4. In an analysis, CPM-2 finds that prompts work as a provider (additional context) and aggregator (aggregate information with the input text) for the model

ERNIE 3.0

1. A modular LLM architecture with a universal representation module and task-specific representation module helps in the finetuning phase 2. Optimizing the parameters of a task-specific representation network during the fine-tuning phase is an efficient way to take advantage of the powerful pre-trained model

Jurassic-1

1. The performance of LLM is highly related to the network size 2. To improve runtime performance, more operations can be performed in parallel (width) rather than sequential (depth) 3. To efficiently represent and fit more text in the same context length, the model uses a larger vocabulary to train a SentencePiece tokenizer without restricting it to word boundaries. This further benefits in few-shot learning tasks

HyperCLOVA

1. By employing prompt-based tuning, the performances of models can be improved, often surpassing those of state-of-the-art models when the backward gradients of inputs are accessible

Yuan 1.0

1. The model architecture that excels in pre-training and fine-tuning cases may exhibit contrasting behavior in zero-shot and few-shot learning

Gopher

1. Relative encodings enable the model to evaluate for longer sequences than training.

ERNIE 3.0 Titan

1. Additional self-supervised adversarial loss to distinguish between real and generated text improves the model performance as compared to ERNIE 3.0

GPT-NeoX-20B

1. Parallel attention + FF layers speed-up training 15% with the same performance as with cascaded layers 2. Initializing feed-forward output layers before residuals with scheme in \[[153](https://arxiv.org/html/2307.06435v10#bib.bib153)\] avoids activations from growing with increasing depth and width 3. Training on Pile outperforms GPT-3 on five-shot

Table Continued on Next Page

\\rowcolorgray!50Models

Findings & Insights

OPT

1. Restart training from an earlier checkpoint with a lower learning rate if loss diverges 2. Model is prone to generate repetitive text and stuck in a loop

Galactica

1. Galactica’s performance has continued to improve across validation set, in-domain, and out-of-domain benchmarks, even with multiple repetitions of the corpus, which is superior to existing research on LLMs 2. A working memory token approach can achieve strong performance over existing methods on mathematical MMLU and MATH benchmarks. It sets a new state-of-the-art on several downstream tasks such as PubMedQA (77.6%) and MedMCQA dev (52.9%)

GLaM

1. The model capacity can be maintained at reduced computation by replacing the feed-forward layer in each transformer layer with a mixture-of-experts (MoE) 2. The model trained on filtered data shows consistently better performances on both NLG and NLU tasks, where the effect of filtering is more significant on the former tasks 3. Filtered pretraining corpora play a crucial role in the generation capability of LLMs, especially for the downstream tasks 4. The scaling of GLaM MoE models can be achieved by increasing the size or number of experts in the MoE layer. Given a fixed budget of computation, more experts contribute to a better performance

LaMDA

1. The model can be fine-tuned to learn to call different external information resources and tools

AlphaCode

1. For higher effectiveness and efficiency, a transformer model can be asymmetrically constructed with a shallower encoder and a deeper decoder 2. To achieve better performances, it is necessary to employ strategies such as massively scaling upsampling, followed by the filtering and clustering of samples into a compact set 3. The utilization of novel sampling-efficient transformer architectures designed to facilitate large-scale sampling is crucial 4. Simplifying problem descriptions can effectively improve the model’s performance

Chinchilla

1. The model size and the number of training tokens should be scaled proportionately: for each doubling of the model size, the number of training tokens should be doubled as well

PaLM

1. English-centric models produce better translations when translating to English as compared to non-English 2. Generalized models can have equivalent performance for language translation to specialized small models 3. Larger models have a higher percentage of training data memorization 4. Performance has not yet saturated even at 540B scale, which means larger models are likely to perform better

AlexaTM

1. Encoder-decoder architecture is more suitable to train LLMs given bidirectional attention to the context than decoder-only 2. Causal Language Modeling (CLM) task can be added to benefit the model with efficient in-context learning 3. Placing layer norm at the beginning of each transformer layer improves the training stability

Table Continued on Next Page

\\rowcolorgray!50Models

Findings & Insights

U-PaLM

1. Training with a mixture of denoisers outperforms PaLM when trained further for a few more FLOPs 2. Training with a mixture of denoisers improves the infilling ability and open-ended text generation diversity

UL2

1. Mode switching training enables better performance on downstream tasks 2. CoT prompting outperforms standard prompting for UL2

GLM-130B

1. Pre-training data with a small proportion of multi-task instruction data improves the overall model performance

CodeGen

1. Multi-step prompting for code synthesis leads to a better user intent understanding and code generation

LLaMA

1. A constant performance improvement is observed when scaling the model 2. Smaller models can achieve good performances with more training data and computing time

PanGu-ΣΣ\\Sigmaroman\_Σ

1. Sparse models provide the benefits of large models at a lower computation cost 2. Randomly Routed Experts reduces catastrophic forgetting effects which in turn is essential for continual learning 3. Randomly Routed Experts allow extracting a domain-specific sub-model in deployment which is cost-efficient while maintaining a performance similar to the original

BloombergGPT

1. Pre-training with general-purpose and task-specific data improves task performance without hurting other model capabilities

XuanYuan 2.0

1. Combining pre-training and fine-tuning stages in single training avoids catastrophic forgetting

CodeT5+

1. Causal LM is crucial for a model’s generation capability in encoder-decoder architectures 2. Multiple training objectives like span corruption, Causal LM, matching, etc complement each other for better performance

StarCoder

1. HHH prompt by Anthropic allows the model to follow instructions without fine-tuning

LLaMA-2

1. Model trained on unfiltered data is more toxic but may perform better on downstream tasks after fine-tuning 2. Model trained on unfiltered data requires fewer samples for safety alignment

PaLM-2

1. Data quality is important to train better models 2. Model and data size should be scaled with 1:1 proportions 3. Smaller models trained for larger iterations outperform larger models

LLaMA-3/3.1

1. Increasing batch size gradually stabilizes the training without loss spikes 2. High-quality data at the final stages of training improves the model performance 3. Increasing model context length windows step-wise allows it to better adapt to various sequence lengths

Nemotron-40B

1. Model aligned iteratively on synthetic data with data generated from the previously aligned model achieves competitive performance

DeepSeek

1. Batch size should increase with the increase in compute budget while decreasing the learning rate

DeepSeek-v2

1. Mult-head latent attention (MLA) performs better than multi-head attention (MHA) while requiring a significantly smaller KV cache, therefore achieving faster data generation

Table 2: Key insights and findings from the study of _instruction-tuned_ Large Language Models.

\\rowcolorgray!50Models

Findings & Insights

T0

1. Multi-task prompting enables zero-shot generalization and outperforms baselines 2. Even a single prompt per dataset task is enough to improve performance

WebGPT

1. To aid the model in effectively filtering and utilizing relevant information, human labelers play a crucial role in answering questions regarding the usefulness of the retrieved documents 2. Interacting a fine-tuned language model with a text-based web-browsing environment can improve end-to-end retrieval and synthesis via imitation learning and reinforcement learning 3. Generating answers with references can make labelers easily judge the factual accuracy of answers

Tk-INSTRUCT

1. Instruction tuning leads to a stronger generalization of unseen tasks 2. More tasks improve generalization whereas only increasing task instances does not help 3. Supervised trained models are better than generalized models 4. Models pre-trained with instructions and examples perform well for different types of inputs

mT0 and BLOOMZ

1. Instruction tuning enables zero-shot generalization to tasks never seen before 2. Multi-lingual training leads to even better zero-shot generalization for both English and non-English 3. Training on machine-translated prompts improves performance for held-out tasks with non-English prompts 4. English only fine-tuning on multilingual pre-trained language model is enough to generalize to other pre-trained language tasks

OPT-IML

1. Creating a batch with multiple task examples is important for better performance 2. Only example proportional sampling is not enough, training datasets should also be proportional for better generalization/performance 3. Fully held-out and partially supervised tasks performance improves by scaling tasks or categories whereas fully supervised tasks have no effect 4. Including small amounts i.e. 5% of pretraining data during fine-tuning is effective 5. Only 1% reasoning data improves the performance, adding more deteriorates performance 6. Adding dialogue data makes the performance worse

Sparrow

1. Labelers’ judgment and well-defined alignment rules help the model generate better responses 2. Good dialogue goals can be broken down into detailed natural language rules for the agent and the raters 3. The combination of reinforcement learning (RL) with reranking yields optimal performance in terms of preference win rates and resilience against adversarial probing

Flan

1. Finetuning with CoT improves performance on held-out tasks 2. Fine-tuning along with CoT data improves reasoning abilities 3. CoT tuning improves zero-shot reasoning 4. Performance improves with more tasks 5. Instruction fine-tuning improves usability which otherwise is challenging for pre-trained models 6. Improving the model’s performance with instruction tuning is compute-efficient 7. Multitask prompting enables zero-shot generalization abilities in LLM

WizardCoder

1. Fine-tuning with re-written instruction-tuning data into a complex set improves performance

LLaMA-2-Chat

1. Model learns to write safe responses with fine-tuning on safe demonstrations, while additional RLHF step further improves model safety and make it less prone to jailbreak attacks

LIMA

1. Less high quality data is enough for fine-tuned model generalization

### 3.2 Fine-Tuned LLMs

Pre-trained LLMs have excellent generalization abilities to unseen tasks. However, because they are generally trained with the objective of next token prediction, LLMs have limited capacity to follow user intent and are prone to generate unethical, toxic or inaccurate responses \[[20](https://arxiv.org/html/2307.06435v10#bib.bib20)\]. For their effective utilization, LLMs are fine-tuned to follow instructions \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16), [17](https://arxiv.org/html/2307.06435v10#bib.bib17), [97](https://arxiv.org/html/2307.06435v10#bib.bib97)\] and generate safe responses \[[20](https://arxiv.org/html/2307.06435v10#bib.bib20)\], which also results in increasing zero-shot, few-shot, and cross-task generalization \[[97](https://arxiv.org/html/2307.06435v10#bib.bib97), [16](https://arxiv.org/html/2307.06435v10#bib.bib16), [18](https://arxiv.org/html/2307.06435v10#bib.bib18)\], with minimal compute increment, e.g., 0.2% of the total pre-training for PaLM 540B \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16)\].  
We review various fine-tuned LLMs and strategies for effective fine-tuning in this section.

#### 3.2.1 Instruction-Tuning with Manually Created Datasets

Numerous hand-crafted instruction-tuning datasets with different design choices are proposed in the literature to instruction-tune LLMs. The performance of fine-tuned LLMs depends on multiple factors, such as dataset, instruction diversity, prompting templates, model size, and training objectives. Keeping this in view, diverse fine-tuned models have emerged in the literature using manually created datasets.  
The models T0 \[[17](https://arxiv.org/html/2307.06435v10#bib.bib17)\] and mT0 (multi-lingual) \[[154](https://arxiv.org/html/2307.06435v10#bib.bib154)\] employ templates to convert existing datasets into prompt datasets. They have shown improvements in generalization to zero-shot and held-out tasks. Tk-Instruct \[[18](https://arxiv.org/html/2307.06435v10#bib.bib18)\] fine-tuned the T5 model with in-context instructions to study generalization on unseen tasks when given in-context instructions during test time. The model outperformed Instruct-GPT, despite being smaller in size, i.e., 11B parameters as compared to 175B of GPT-3.  
_Increasing Tasks and Prompt Setups:_ Zero-shot and few-shot performance improves significantly by expanding task collection and prompt styles. OPT-IML \[[97](https://arxiv.org/html/2307.06435v10#bib.bib97)\] and Flan \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16)\] curated larger 2k and 1.8k task datasets, respectively. While increasing task size alone is not enough, OPT-IML and Flan add more prompting setups in their datasets, zero-shot, few-shot, and CoT. In continuation, CoT Collection \[[101](https://arxiv.org/html/2307.06435v10#bib.bib101)\] fine-tunes Flan-T5 further on 1.88M CoT samples. Another method \[[102](https://arxiv.org/html/2307.06435v10#bib.bib102)\] uses symbolic tasks with tasks in T0, Flan, etc.  

[Image: Refer to caption](extracted/5933067/Flan.png)

Figure 11: An example image shows an instance of the Flan training paradigm, taken from \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16)\].

#### 3.2.2 Instruction-Tuning with LLMs Generated Datasets

Generating an instruction-tuning dataset requires carefully writing instructions and input-output pairs, which are often written by humans, smaller in size, and less diverse. To overcome this, self-instruct \[[19](https://arxiv.org/html/2307.06435v10#bib.bib19)\] proposed an approach to prompt available LLMs to generate instruction-tuning datasets. Self-instruct outperformed models trained on manually created dataset SUPER-NATURALINSTRUCTIONS (a dataset with 1600+ tasks) \[[18](https://arxiv.org/html/2307.06435v10#bib.bib18)\] by 33%. It starts with a seed of 175 tasks, 1 instruction, and 1 sample per task and iteratively generates new instructions (52k) and instances (82k input-output pairs) using GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\]. Contrary to this, Dynosaur \[[155](https://arxiv.org/html/2307.06435v10#bib.bib155)\] uses the meta-data of datasets on Huggingface to prompt LLMs to generate multiple task instruction-tuning datasets.  
_LLaMA Tuned:_ Various models in the literature instruction-tune LLaMA \[[156](https://arxiv.org/html/2307.06435v10#bib.bib156)\] with GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\] or GPT-4 \[[157](https://arxiv.org/html/2307.06435v10#bib.bib157)\] generated datasets. Among these, Alpaca \[[158](https://arxiv.org/html/2307.06435v10#bib.bib158)\], Vicuna \[[159](https://arxiv.org/html/2307.06435v10#bib.bib159)\], and LLaMA-GPT-4 \[[160](https://arxiv.org/html/2307.06435v10#bib.bib160)\] are a few general-purpose fine-tuned models, where Alpaca is trained on 52k samples from text-davinci-003, Vicuna on 70k samples from ShareGPT.com, and LLaMA-GPT-4 by re-creating Alpaca instructions from GPT-4. Goat \[[161](https://arxiv.org/html/2307.06435v10#bib.bib161)\] fine-tunes LLaMA for arithmetic tasks (1 million samples) by generating data from ChatGPT and outperforms GPT-4, PaLM, BLOOM, OPT, etc., attributing its success to the LLaMA’s consistent tokenization of numbers. HuaTuo \[[162](https://arxiv.org/html/2307.06435v10#bib.bib162)\] is a medical knowledge model, fine-tuned with a generated QA dataset of 8k instructions.  
_Complex Instructions:_ Evol-Instruct \[[163](https://arxiv.org/html/2307.06435v10#bib.bib163), [164](https://arxiv.org/html/2307.06435v10#bib.bib164)\] prompts LLMs to convert given instructions into a more complex set. The instructions are iteratively evolved with re-writing instructions in complex wording and creating new instructions. With this style of automated instruction generation, WizardLM \[[163](https://arxiv.org/html/2307.06435v10#bib.bib163)\] (fine-tuned LLaMA on 250k instructions), outperforms Vicuna and Alpaca, and WizardCoder \[[164](https://arxiv.org/html/2307.06435v10#bib.bib164)\] (fine-tuned StarCoder) beats Claude-Plus, Bard, and others.

#### 3.2.3 Aligning with Human Preferences

Incorporating human preferences into LLMs presents a significant advantage in mitigating undesirable behaviors and ensuring accurate outputs. The initial work on alignment, such as InstructGPT \[[20](https://arxiv.org/html/2307.06435v10#bib.bib20)\] aligns GPT-3 using a 3-step approach, instruction-tuning, reward modeling, and fine-tuning with reinforcement learning (RL). The supervised fine-tuned GPT-3 on demonstrations is queried to generate responses, which human labelers rank according to human values, and a reward model is trained on the ranked data. Lastly, the GPT-3 is trained with proximal policy optimization (PPO) using rewards on the generated data from the reward model. LLaMA 2-Chat \[[21](https://arxiv.org/html/2307.06435v10#bib.bib21)\] improves alignment by dividing reward modeling into helpfulness and safety rewards and using rejection sampling in addition to PPO. The initial four versions of LLaMA 2-Chat are fine-tuned with rejection sampling and then with PPO on top of rejection sampling.  
  _Aligning with Supported Evidence:_ This style of alignment allows the model to generate responses with proofs and facts, reduces hallucination, and assists humans more effectively, which increases trust in the model’s output. Similar to the RLHF training style, a reward model is trained to rank generated responses containing web citations in answers to questions, which is later used to train the model, as in GopherCite \[[165](https://arxiv.org/html/2307.06435v10#bib.bib165)\], WebGPT \[[166](https://arxiv.org/html/2307.06435v10#bib.bib166)\], and Sparrow \[[167](https://arxiv.org/html/2307.06435v10#bib.bib167)\]. The ranking model in Sparrow \[[167](https://arxiv.org/html/2307.06435v10#bib.bib167)\] is divided into two branches, preference reward and rule reward, where human annotators adversarial probe the model to break a rule. These two rewards together rank a response to train with RL.  
  _Aligning Directly with SFT:_ The PPO in the RLHF pipeline is complex, memory-intensive, and unstable, requiring multiple models, reward, value, policy, and reference models. Avoiding this sophisticated alignment pipeline is possible by incorporating minimal changes in the supervised fine-tuning (SFT) pipeline as in \[[168](https://arxiv.org/html/2307.06435v10#bib.bib168), [169](https://arxiv.org/html/2307.06435v10#bib.bib169), [170](https://arxiv.org/html/2307.06435v10#bib.bib170)\], with better or comparable performance to PPO. Direct preference optimization (DPO) \[[168](https://arxiv.org/html/2307.06435v10#bib.bib168)\] trains a model directly on the human-preferred responses to maximize the likelihood of preferred against unpreferred responses, with per-sample importance weight. Reward ranked fine-tuning RAFT \[[169](https://arxiv.org/html/2307.06435v10#bib.bib169)\] fine-tunes the model on ranked responses by the reward model. Preference ranking optimization (PRO) \[[171](https://arxiv.org/html/2307.06435v10#bib.bib171)\] and RRHF \[[170](https://arxiv.org/html/2307.06435v10#bib.bib170)\] penalize the model to rank responses with human preferences and supervised loss. On the other hand, chain-of-hindsight (CoH) \[[172](https://arxiv.org/html/2307.06435v10#bib.bib172)\] provides feedback to the model in language rather than reward, to learn good versus bad responses.  
 _Aligning with Synthetic Feedback:_ Aligning LLMs with human feedback is slow and costly. The literature suggests a semi-automated process to align LLMs by prompting LLMs to generate helpful, honest, and ethical responses to the queries, and fine-tuning using the newly created dataset. Constitutional AI \[[173](https://arxiv.org/html/2307.06435v10#bib.bib173)\] replaces human feedback in RLHF with AI, calling it RL from AI feedback (RLAIF). AlpacaFarm \[[174](https://arxiv.org/html/2307.06435v10#bib.bib174)\] designs prompts to imitate human feedback using LLMs APIs. Opposite to constitutional AI, AlpacaFarm injects noise in feedback to replicate human mistakes. Self-Align \[[98](https://arxiv.org/html/2307.06435v10#bib.bib98)\] prompts the LLM with ICL examples, instructing the LLM about what the response should contain to be considered useful and ethical. The same LLM is later fine-tuned with the new dataset.  
  _Aligning with Prompts:_ LLMs can be steered with prompts to generate desirable responses without training \[[175](https://arxiv.org/html/2307.06435v10#bib.bib175), [176](https://arxiv.org/html/2307.06435v10#bib.bib176)\]. The self-correction prompting in \[[176](https://arxiv.org/html/2307.06435v10#bib.bib176)\] concatenates instructions and CoT with questions, guiding the model to answer its instruction following a strategy to ensure moral safety before the actual answer. This strategy is shown to reduce the harm in generated responses significantly.  
  _Red-Teaming/Jailbreaking/Adversarial Attacks:_ LLMs exhibit harmful behaviors, hallucinations, leaking personal information, and other shortcomings through adversarial probing. The models are susceptible to generating harmful responses even though they are aligned for safety \[[177](https://arxiv.org/html/2307.06435v10#bib.bib177), [178](https://arxiv.org/html/2307.06435v10#bib.bib178)\]. Red-teaming is a common approach to address illicit outputs, where the LLMs are prompted to generate harmful outputs \[[178](https://arxiv.org/html/2307.06435v10#bib.bib178), [179](https://arxiv.org/html/2307.06435v10#bib.bib179)\]. The dataset collected through red-teaming is used to fine-tune models for safety. While red-teaming largely relies on human annotators, another work \[[180](https://arxiv.org/html/2307.06435v10#bib.bib180)\] red-team LLMs to find prompts that lead to harmful outputs for other LLMs.  

#### 3.2.4 Continue Pre-Training

Although fine-tuning boosts a model’s performance, it leads to catastrophic forgetting of previously learned information. Concatenating fine-tuning data with a few randomly selected pre-training samples in every iteration avoids network forgetting \[[181](https://arxiv.org/html/2307.06435v10#bib.bib181), [152](https://arxiv.org/html/2307.06435v10#bib.bib152)\]. This is also effective in adapting LLMs for cases where fine-tuning data is small and the original capacity is to be maintained. Prompt-based continued pre-training (PCP) \[[182](https://arxiv.org/html/2307.06435v10#bib.bib182)\] trains the model with text and instructions related to tasks and then finally instruction-tunes the model for downstream tasks.

#### 3.2.5 Sample Efficiency

While fine-tuning data is generally many-fold smaller than the pre-training data, it still has to be large enough for acceptable performance \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16), [97](https://arxiv.org/html/2307.06435v10#bib.bib97), [18](https://arxiv.org/html/2307.06435v10#bib.bib18)\] and requires proportional computing resources. Studying the effects on performance with less data, existing literature \[[183](https://arxiv.org/html/2307.06435v10#bib.bib183), [184](https://arxiv.org/html/2307.06435v10#bib.bib184)\] finds that models trained on less data can outperform models trained with more data. In \[[183](https://arxiv.org/html/2307.06435v10#bib.bib183)\], 25% of the total downstream data is found enough for state-of-the-art performance. Selecting coreset-based 0.5% of the total instruction-tuning data improves the model performance by 2% in \[[184](https://arxiv.org/html/2307.06435v10#bib.bib184)\], as compared to the complete data tuning. Less is more for alignment (LIMA) \[[185](https://arxiv.org/html/2307.06435v10#bib.bib185)\] uses only 1000 carefully created demonstrations to fine-tune the model and has achieved comparable performance to GPT-4.

### 3.3 Increasing Context Window

LLMs are trained with limited context windows due to expensive attention and high memory requirements. A model trained on limited sequence lengths fails to generalize to unseen lengths at inference time \[[186](https://arxiv.org/html/2307.06435v10#bib.bib186), [49](https://arxiv.org/html/2307.06435v10#bib.bib49)\]. Alternatively, LLMs with ALiBi \[[65](https://arxiv.org/html/2307.06435v10#bib.bib65)\] positional encodings can perform zero-shot length extrapolation. However, ALiBi has less expressive power \[[66](https://arxiv.org/html/2307.06435v10#bib.bib66)\] and inferior performance on multiple benchmarks \[[46](https://arxiv.org/html/2307.06435v10#bib.bib46)\], and many LLMs use RoPE positional embedding that is unable to perform zero-shot extrapolation. A larger context length has benefits such as a better understanding of longer documents, more samples in in-context learning, execution of bigger reasoning processes, etc. Expanding context length during fine-tuning is slow, inefficient, and computationally expensive \[[49](https://arxiv.org/html/2307.06435v10#bib.bib49)\]. Therefore, researchers employ various context window extrapolation techniques discussed below.  
_Position Interpolation:_ Rather than extrapolating, \[[49](https://arxiv.org/html/2307.06435v10#bib.bib49)\] shows that interpolating position encodings within the pre-trained context window are more effective. The work demonstrates that only 1000 steps of fine-tuning are enough to achieve better results on larger windows without reducing performance compared to the original context size. Giraffe \[[46](https://arxiv.org/html/2307.06435v10#bib.bib46)\] uses power scaling in RoPE, and YaRN \[[47](https://arxiv.org/html/2307.06435v10#bib.bib47)\] proposed NTK-aware interpolation.  
_Efficient Attention Mechanism:_ Dense global attention is one of the major constraints in training larger context window LLMs. Using efficient attention variants, such as local, sparse, and dilated attention, reduces the computation cost significantly. LongT5 \[[48](https://arxiv.org/html/2307.06435v10#bib.bib48)\] proposes transient global attention (TGlobal), applying attention to local and global tokens (windowed token averaging). The model replaces attention in T5 \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\] with TGlobal attention, pre-trains the model on 4098 sequence length, fine-tunes on larger window sizes, as large as 16k, and improves task performance on longer inputs. This shows the extrapolation ability of TGlobal attention with only fine-tuning. COLT5 \[[187](https://arxiv.org/html/2307.06435v10#bib.bib187)\] uses two branches, one with lightweight and the other with heavyweight attention and feed-forward layers. All tokens are processed from the lightweight branch, and only important tokens are routed to the heavyweight branch. LongNet \[[188](https://arxiv.org/html/2307.06435v10#bib.bib188)\] replaces standard attention with dilated attention, expanding sequence length to 1 billion tokens. LongLoRA \[[189](https://arxiv.org/html/2307.06435v10#bib.bib189)\] proposes shift-short attention, used during fine-tuning to reduce dense attention costs. However, the model during inference uses dense attention and achieves similar performance as full attention fine-tuning.  
_Extrapolation without Training:_ LM-Infinite \[[186](https://arxiv.org/html/2307.06435v10#bib.bib186)\] and parallel context windows (PCW) \[[190](https://arxiv.org/html/2307.06435v10#bib.bib190)\] show length extrapolation is possible using pre-trained LLMs. LM-Infinite suggested ΛΛ\\Lambdaroman\_Λ\-shaped attention applied within the original context window limits. Likewise, PCW chunks larger inputs into the pre-trained context lengths and applies the same positional encodings to each chunk.

### 3.4 Augmented LLMs

LLMs are capable of learning from the examples concatenated with the input, known as context augmentation, in-context learning (ICL), or few-shot prompting. They show excellent generalization to unseen tasks with few-shot prompting, enabling LLMs to answer queries beyond the capacity acquired during training \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6), [55](https://arxiv.org/html/2307.06435v10#bib.bib55)\]. These emergent abilities allow for adapting the model without fine-tuning—a costly process. Aside from this, hallucination, producing inaccurate, unsafe, or factually incorrect responses, is common for LLMs, which is avoided by augmenting contextual data. While the user can provide in-context samples in the query \[[54](https://arxiv.org/html/2307.06435v10#bib.bib54), [32](https://arxiv.org/html/2307.06435v10#bib.bib32)\], here we specifically refer to the methods that access external storage programmatically, calling them augmented LLMs.  
The literature suggests various external memory designs to augment LLMs, long-term \[[191](https://arxiv.org/html/2307.06435v10#bib.bib191), [192](https://arxiv.org/html/2307.06435v10#bib.bib192), [193](https://arxiv.org/html/2307.06435v10#bib.bib193), [194](https://arxiv.org/html/2307.06435v10#bib.bib194)\], short-term \[[195](https://arxiv.org/html/2307.06435v10#bib.bib195)\], symbolic \[[196](https://arxiv.org/html/2307.06435v10#bib.bib196)\], and non-symbolic \[[197](https://arxiv.org/html/2307.06435v10#bib.bib197), [198](https://arxiv.org/html/2307.06435v10#bib.bib198)\]. The memory can be maintained in different formats such as documents, vectors, or databases. A few systems maintain intermediate memory representations to retain information across multiple iterations \[[194](https://arxiv.org/html/2307.06435v10#bib.bib194), [192](https://arxiv.org/html/2307.06435v10#bib.bib192)\], while others extract important information from the datasets and save it in memory for recall \[[199](https://arxiv.org/html/2307.06435v10#bib.bib199)\]. The memory read and write operations are performed either with or without LLMs cooperation \[[192](https://arxiv.org/html/2307.06435v10#bib.bib192), [200](https://arxiv.org/html/2307.06435v10#bib.bib200), [194](https://arxiv.org/html/2307.06435v10#bib.bib194), [201](https://arxiv.org/html/2307.06435v10#bib.bib201)\], acting as a feedback signal in \[[195](https://arxiv.org/html/2307.06435v10#bib.bib195)\]. We discuss different types of augmented LLMs below.

[Image: Refer to caption](extracted/5933067/RAG.png)

Figure 12: A flow diagram of Retrieval Augmented LLMs. The retriever extracts a similar context to the input and forwards it to the LLM either in simple language or encoded through Fusion-in-Decoder (FiD). Depending on the task, retrieval and generation may repeat multiple times.

#### 3.4.1 Retrieval Augmented LLMs

LLMs may have limited memory and outdated information, leading to inaccurate responses. Retrieving relevant information from external up-to-date storage enables the LLMs to accurately answer with references and utilize more information. With retrieval augmentation, smaller models have been shown to perform at par with larger models. For instance, the 11B model can become competitive to 540B PaLM in \[[25](https://arxiv.org/html/2307.06435v10#bib.bib25)\] and 7.5B to 280B Gopher in \[[193](https://arxiv.org/html/2307.06435v10#bib.bib193)\]. Retrieval augmented language modeling (RALM) has two major components, shown in Figure [12](https://arxiv.org/html/2307.06435v10#S3.F12 "Figure 12 ‣ 3.4 Augmented LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"), namely: 1) retriever and 2) language model. In RALM, the retriever plays a crucial role in driving LLM response, where incorrect information can steer LLMs to false behavior. This leads to the development of various methods to retrieve accurate information and fuse with the query for better performance.  
_Zero-Shot Retrieval Augmentation:_ This kind of augmentation keeps the original LLM architecture and weights unchanged and uses BM25 \[[202](https://arxiv.org/html/2307.06435v10#bib.bib202)\], nearest neighbors, or frozen pre-trained models like Bert \[[7](https://arxiv.org/html/2307.06435v10#bib.bib7)\] as a retriever. The retrieved information is provided as input to the model for response generation, shown to improve performance over LLMs without retrieval \[[198](https://arxiv.org/html/2307.06435v10#bib.bib198), [203](https://arxiv.org/html/2307.06435v10#bib.bib203)\]. In some scenarios, multiple retrieval iterations are required to complete the task. The output generated in the first iteration is forwarded to the retriever to fetch similar documents. Forward-looking active retrieval (FLARE) \[[197](https://arxiv.org/html/2307.06435v10#bib.bib197)\] initially generates the response and corrects the output by retrieving relevant documents if the response contains low-confidence tokens. Similarly, RepoCoder \[[204](https://arxiv.org/html/2307.06435v10#bib.bib204)\] fetches code snippets recursively for code completion.  
_Training with Retrieval Augmentation:_ To reduce failures in retrieval augmentation generation (RAG), researchers train or fine-tune retrievers and LLMs with a retrieval augmentation pipeline. We discuss the literature below based on their focus on the respective training processes of the pipeline.  
Training LLM: Retrieval-enhanced transformer (RETRO) \[[193](https://arxiv.org/html/2307.06435v10#bib.bib193)\] shows pre-training smaller LLMs with RAG pipeline outperforms larger LLMs, such as GPT-3 trained without RAG. RETRO uses a 2-trillion token subset of MassiveText as a database. The retrieval pipeline divides the input query into subsets and retrieves relevant chunks from the database for each subset, encoded together with input intermediate representations for generating tokens. It uses cross-chunked attention to attend to previous chunks auto-regressively. A study on RETRO \[[205](https://arxiv.org/html/2307.06435v10#bib.bib205)\] shows models pre-trained without RAG but fine-tuned using RAG lack the performance gains obtained by pre-training with RAG.  
Training Retriever: Quality of responses generated by LLMs is highly dependent on the in-context examples. Therefore, \[[206](https://arxiv.org/html/2307.06435v10#bib.bib206), [207](https://arxiv.org/html/2307.06435v10#bib.bib207), [208](https://arxiv.org/html/2307.06435v10#bib.bib208), [209](https://arxiv.org/html/2307.06435v10#bib.bib209)\] train retrievers to retrieve accurate few-shot samples while keeping the LLM frozen for generation. Retrieved samples are ranked to build ground-truth data to train retrievers with contrastive learning in \[[206](https://arxiv.org/html/2307.06435v10#bib.bib206), [208](https://arxiv.org/html/2307.06435v10#bib.bib208)\]. RoBERTa is trained for downstream tasks in \[[207](https://arxiv.org/html/2307.06435v10#bib.bib207)\] for ICL samples retrieval. REPLUG \[[209](https://arxiv.org/html/2307.06435v10#bib.bib209)\] trains the retriever with supervised signals from the frozen LLM-generated outputs.  
Training Retriever and LLM: Further benefits are achieved by training both the retriever and the model in \[[25](https://arxiv.org/html/2307.06435v10#bib.bib25), [210](https://arxiv.org/html/2307.06435v10#bib.bib210), [211](https://arxiv.org/html/2307.06435v10#bib.bib211)\]. In this case, the error propagates back to the retriever, updating both the language model and the retriever. While masked language modeling (MLM) is a common pre-training objective \[[25](https://arxiv.org/html/2307.06435v10#bib.bib25), [211](https://arxiv.org/html/2307.06435v10#bib.bib211)\], retrieval pre-trained transformer (RPT) \[[210](https://arxiv.org/html/2307.06435v10#bib.bib210)\] used document chunk prediction as a pre-training objective for long text modeling.  
_Encoded Context Augmentation:_ Concatenating retrieved documents with the query becomes infeasible as the sequence length and sample size grow. Encoding the context and fusing it with the decoder (Fusion-in-Decoder) using cross-attention makes it possible to augment more samples without increasing computation costs significantly \[[212](https://arxiv.org/html/2307.06435v10#bib.bib212), [193](https://arxiv.org/html/2307.06435v10#bib.bib193), [210](https://arxiv.org/html/2307.06435v10#bib.bib210), [25](https://arxiv.org/html/2307.06435v10#bib.bib25)\].  
_Web Augmented:_ Locally stored memory, but external to LLM, has limited information. However, a large amount of information is available on the internet, which gets updated regularly. Rather than storing information locally, various methods retrieve query-related context through a web search and forward it to LLMs \[[213](https://arxiv.org/html/2307.06435v10#bib.bib213), [214](https://arxiv.org/html/2307.06435v10#bib.bib214), [166](https://arxiv.org/html/2307.06435v10#bib.bib166)\].  

#### 3.4.2 Tool Augmented LLMs

While RAG relies on the retriever to provide context to the LLM to answer queries, tool augmented LLMs capitalize on the reasoning abilities of LLMs to iteratively plan by dividing tasks into sub-tasks, selecting necessary tools, and taking actions to complete the task \[[215](https://arxiv.org/html/2307.06435v10#bib.bib215), [216](https://arxiv.org/html/2307.06435v10#bib.bib216), [217](https://arxiv.org/html/2307.06435v10#bib.bib217), [27](https://arxiv.org/html/2307.06435v10#bib.bib27)\]. A generic pipeline of tool-augmented LLMs is shown in Figure [13](https://arxiv.org/html/2307.06435v10#S3.F13 "Figure 13 ‣ 3.4.2 Tool Augmented LLMs ‣ 3.4 Augmented LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"), where different modules in Figure [13](https://arxiv.org/html/2307.06435v10#S3.F13 "Figure 13 ‣ 3.4.2 Tool Augmented LLMs ‣ 3.4 Augmented LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models") are selected in a loop until the task completion.

[Image: Refer to caption](extracted/5933067/TALLM.png)

Figure 13: A basic flow diagram of tool augmented LLMs. Given an input and a set of available tools, the model generates a plan to complete the task. The tool augmented LLMs utilize different modules iteratively, such as retriever, tool execution, read-write to memory, feedback, etc., depending on the task.

_Zero-Shot Tool Augmentation:_ LLMs in-context learning and reasoning abilities enable them to interact with tools without training. Automatic reasoning and tool-use (ART) \[[217](https://arxiv.org/html/2307.06435v10#bib.bib217)\] builds a task library with demonstrations of reasoning steps and calling external tools. It retrieves similar task examples and provides the context to the LLM for inference. Aside from this, \[[218](https://arxiv.org/html/2307.06435v10#bib.bib218)\] shows tool documentation is enough to teach LLMs to use tools without demonstrations. RestGPT \[[219](https://arxiv.org/html/2307.06435v10#bib.bib219)\] integrates LLMs with RESTful APIs by decomposing tasks into planning and API selection steps. The API selector understands the API documentation to select a suitable API for the task and plan the execution. ToolkenGPT \[[220](https://arxiv.org/html/2307.06435v10#bib.bib220)\] uses tools as tokens by concatenating tool embeddings with other token embeddings. During inference, the LLM generates the tool tokens representing the tool call, stops text generation, and restarts using the tool execution output.  
_Training with Tool Augmentation:_ LLMs are trained to interact with diverse tools, enhancing planning abilities to overcome the limitations of zero-shot tool augmentation \[[221](https://arxiv.org/html/2307.06435v10#bib.bib221), [27](https://arxiv.org/html/2307.06435v10#bib.bib27), [222](https://arxiv.org/html/2307.06435v10#bib.bib222), [223](https://arxiv.org/html/2307.06435v10#bib.bib223)\]. Gorilla \[[221](https://arxiv.org/html/2307.06435v10#bib.bib221)\] instruction-tunes LLaMA with information retrieval from API documentation. It uses the self-instruct \[[19](https://arxiv.org/html/2307.06435v10#bib.bib19)\] data generation pipeline with GPT-4 by providing in-context examples retrieved from API documentation. Tool augmented language model (TALM) \[[27](https://arxiv.org/html/2307.06435v10#bib.bib27)\] fine-tunes T5 \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\] for tool use with a self-play approach, where it iteratively completes tool manipulation tasks and includes them back in the training set. ToolLLM \[[223](https://arxiv.org/html/2307.06435v10#bib.bib223)\] collects 16k APIs from RapidAPI. It samples APIs from the list to generate an instruction-tuning dataset using ChatGPT in single-tool and multi-tool scenarios. For high-quality datasets, ToolLLM suggested a depth-first search-based decision tree (DFSDT) method to generate ground-truths with diverse reasoning and planning.  
_Multimodal Tool Augmentation:_ The compositional reasoning capacity of LLMs allows them to manipulate tools in multimodal settings \[[215](https://arxiv.org/html/2307.06435v10#bib.bib215), [216](https://arxiv.org/html/2307.06435v10#bib.bib216), [224](https://arxiv.org/html/2307.06435v10#bib.bib224)\]. Following the pipeline shown in Figure [13](https://arxiv.org/html/2307.06435v10#S3.F13 "Figure 13 ‣ 3.4.2 Tool Augmented LLMs ‣ 3.4 Augmented LLMs ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models"), the LLM outlines a plan, generally executing in a sequence: Plan →→\\,\\to\\,→ Tool selection →→\\,\\to\\,→ Execute →→\\,\\to\\,→ Inspect →→\\,\\to\\,→ Generate, to respond to the user query. Here, the database of tools is rich in modalities, including text, images, etc. Many of the multimodal tool augmentation systems employ multimodal LLMs \[[31](https://arxiv.org/html/2307.06435v10#bib.bib31), [225](https://arxiv.org/html/2307.06435v10#bib.bib225), [224](https://arxiv.org/html/2307.06435v10#bib.bib224), [216](https://arxiv.org/html/2307.06435v10#bib.bib216)\], while others utilize single modality LLMs and generate a plan on using different modality tools to solve multimodal queries \[[226](https://arxiv.org/html/2307.06435v10#bib.bib226)\].

### 3.5 LLMs-Powered Agents

AI agents are autonomous entities, capable of planning, decision-making, and performing actions to achieve complex goals. In the early days, AI agents were rule-based, designed for narrow tasks, and had limited capabilities, such as Clippy \[[227](https://arxiv.org/html/2307.06435v10#bib.bib227)\] and Deep Blue \[[228](https://arxiv.org/html/2307.06435v10#bib.bib228)\]. In contrast to this, LLMs abilities to respond to dynamic scenarios have made it possible to incorporate them in diverse applications, including LLMs-powered agents \[[224](https://arxiv.org/html/2307.06435v10#bib.bib224), [216](https://arxiv.org/html/2307.06435v10#bib.bib216)\], where LLMs behave as the brain of agents. LLMs have been incorporated in web agents \[[166](https://arxiv.org/html/2307.06435v10#bib.bib166), [167](https://arxiv.org/html/2307.06435v10#bib.bib167)\], coding agents \[[229](https://arxiv.org/html/2307.06435v10#bib.bib229)\], tool agents \[[27](https://arxiv.org/html/2307.06435v10#bib.bib27), [223](https://arxiv.org/html/2307.06435v10#bib.bib223)\], embodied agents \[[26](https://arxiv.org/html/2307.06435v10#bib.bib26)\], and conversational agents \[[195](https://arxiv.org/html/2307.06435v10#bib.bib195)\], requiring minimal to no fine-tuning". Below we summarize the research in LLMs-based autonomous agents. For a more detailed discussion, please refer to \[[230](https://arxiv.org/html/2307.06435v10#bib.bib230), [231](https://arxiv.org/html/2307.06435v10#bib.bib231)\].  
_LLMs Steering Autonomous Agents:_ LLMs are the cognitive controllers of the autonomous agents. They generate plans, reason about tasks, incorporate memory to complete tasks, and adapt the outline depending on the feedback from the environment. Depending on the acquired capabilities of LLMs, many methods fine-tune, propose a better prompting approach, or utilize different modules to enhance agents’ performance. Modules and strategies employed in autonomous agents are briefly discussed below.  
_Planning and Reasoning:_ Completing a complex task requires human-like logical thinking, planning necessary steps, and reasoning current and future directions. Prompting methods like chain-of-thoughts \[[103](https://arxiv.org/html/2307.06435v10#bib.bib103)\], tree-of-thoughts \[[105](https://arxiv.org/html/2307.06435v10#bib.bib105)\], and self-consistency \[[104](https://arxiv.org/html/2307.06435v10#bib.bib104)\] are central to agents, eliciting LLMs to reason its actions and choose among different paths for task completion. When LLMs are prompted with a task description and a sequence of actions, they can accurately generate plan actions without any fine-tuning \[[232](https://arxiv.org/html/2307.06435v10#bib.bib232)\]. Reasoning via planning (RAP) \[[233](https://arxiv.org/html/2307.06435v10#bib.bib233)\] incorporates a re-purposed LLM as a world model to reason about future outcomes and explore alternative paths for task completion. Retroformer \[[234](https://arxiv.org/html/2307.06435v10#bib.bib234)\] uses a retrospective LLM to improve main LLM planning and reasoning capabilities by providing helpful task cues.  
_Feedback:_ LLMs in open-loop systems generate plans and assume that the agent will complete them successfully. However, the actual scenario is different with failures and variable responses from the environment. To correctly complete tasks, many methods use LLMs in a closed-loop where the action response is provided as feedback to the LLMs to re-assess and update the plan as required \[[235](https://arxiv.org/html/2307.06435v10#bib.bib235), [236](https://arxiv.org/html/2307.06435v10#bib.bib236), [237](https://arxiv.org/html/2307.06435v10#bib.bib237), [195](https://arxiv.org/html/2307.06435v10#bib.bib195)\]. Another direction of research exploits LLMs as reward functions to train reinforcement learning (RL) policies instead of humans \[[238](https://arxiv.org/html/2307.06435v10#bib.bib238)\].  
_Memory:_ LLMs can learn from the context provided in the prompt. In addition to internal memory, various systems employ external memory to save the response history. Reflexion \[[195](https://arxiv.org/html/2307.06435v10#bib.bib195)\] maintains an episodic memory to use previous responses as feedback to improve future decision-making. Retroformer \[[234](https://arxiv.org/html/2307.06435v10#bib.bib234)\] improves its responses by employing short-term and long-term memory, where short-term memory contains recent responses and long-term memory keeps summarized failed attempts to add in the prompt as reflection.  
_Multi-Agents Systems:_ LLMs can play user-defined roles and behave like a specific domain expert. In multi-agent systems, each LLM is assigned a unique role, simulating human behavior and collaborating with other agents to complete a complex task \[[229](https://arxiv.org/html/2307.06435v10#bib.bib229), [239](https://arxiv.org/html/2307.06435v10#bib.bib239)\].  
_LLMs in Physical Environment:_ LLMs are good at instruction-following, however, utilizing them for physically grounded tasks requires adaptation, as they lack real-world knowledge. This could lead to generating illogical responses for a particular physical situation \[[240](https://arxiv.org/html/2307.06435v10#bib.bib240), [26](https://arxiv.org/html/2307.06435v10#bib.bib26)\]. SayCan \[[240](https://arxiv.org/html/2307.06435v10#bib.bib240)\] make LLMs aware of the available low-level task operations. LLM (Say) builds a high-level plan to complete the task and a learned affordance function (Can) explores the possibility of executing the plan in the real world. SayCan uses RL to train the language-conditioned affordance function. PaLM-E enables the LLM to solve grounded tasks by training multi-modal LLM feeding inputs directly from the sensors.  
_Manipulation:_ In the area of manipulation \[[236](https://arxiv.org/html/2307.06435v10#bib.bib236), [241](https://arxiv.org/html/2307.06435v10#bib.bib241)\], LLMs enhance a robot’s dexterity and adaptability, excelling in tasks like object recognition, grasping, and collaboration. They analyze visual and spatial information to determine the most effective approach to interact with objects.  
_Navigation:_ LLMs enhance a robot’s ability to navigate complex environments with precision and adaptability \[[242](https://arxiv.org/html/2307.06435v10#bib.bib242), [243](https://arxiv.org/html/2307.06435v10#bib.bib243), [244](https://arxiv.org/html/2307.06435v10#bib.bib244), [245](https://arxiv.org/html/2307.06435v10#bib.bib245)\]. They generate feasible paths and trajectories for robots, accounting for intricate environmental details \[[246](https://arxiv.org/html/2307.06435v10#bib.bib246)\]. This ability is valuable in scenarios requiring precise and dynamically adaptable navigation in environments like warehouses, transport, healthcare facilities, and residences.

[Image: Refer to caption](extracted/5933067/peft.png)

Figure 14: Illustration of parameter-efficient fine-tuning paradigms, where x𝑥xitalic\_x is input and hℎhitalic\_h is hidden state, figure courtesy \[[38](https://arxiv.org/html/2307.06435v10#bib.bib38)\]. Parallel adapter and LoRA fall in the adapter tuning category.

### 3.6 Efficient LLMs

Deploying LLMs in production is expensive. Reducing their running costs while preserving performance is an appealing area of research. This section summarizes the approaches suggested to enhance LLMs’ efficiency.

#### 3.6.1 Parameter Efficient Fine-Tuning

Fine-tuning LLMs with tens or hundreds of billions of parameters, such as GPT-3 (175B), BLOOM (176B), MT-NLG (540B), etc., is computationally intensive and time-consuming. To avoid complete model fine-tuning, numerous parameter-efficient fine-tuning (PEFT) techniques \[[40](https://arxiv.org/html/2307.06435v10#bib.bib40), [247](https://arxiv.org/html/2307.06435v10#bib.bib247), [41](https://arxiv.org/html/2307.06435v10#bib.bib41), [38](https://arxiv.org/html/2307.06435v10#bib.bib38), [39](https://arxiv.org/html/2307.06435v10#bib.bib39)\] try to achieve acceptable model fine-tuning performance at reduced costs. As compared to full fine-tuning \[[248](https://arxiv.org/html/2307.06435v10#bib.bib248)\], PEFT performs better in low-resource setups, achieves comparable performance on medium-resource scenarios, and performs worse than full fine-tuning under high-resource availability. An overview of different PEFT approaches is shown in Figure [14](https://arxiv.org/html/2307.06435v10#S3.F14 "Figure 14 ‣ 3.5 LLMs-Powered Agents ‣ 3 Large Language Models ‣ A Comprehensive Overview of Large Language Models").

_Adapter Tuning:_ Adds a few trainable parameters within the transformer block. The adapter layer is a sequence of feature downscaling, non-linearity, and upscaling \[[106](https://arxiv.org/html/2307.06435v10#bib.bib106)\]. Variants of adapter tuning inject adapter layers sequentially \[[106](https://arxiv.org/html/2307.06435v10#bib.bib106)\] and in parallel \[[38](https://arxiv.org/html/2307.06435v10#bib.bib38)\], whereas the mixture of adapter (AdaMix) \[[249](https://arxiv.org/html/2307.06435v10#bib.bib249)\] employs multiple adapter modules in a single layer. AdaMix routes input instances randomly to one of the multiple downscale and upscale modules. The mixture of adapters is averaged out for inference to avoid additional latency. Low-Rank Adaptation (LoRA) \[[250](https://arxiv.org/html/2307.06435v10#bib.bib250)\] learns low-rank decomposed matrices to freeze original weights. The learned weights are fused with the original weights for inference, avoiding latency.  
_Prompt Tuning:_ Prompting is an effective way to adapt a pre-trained LLM for the downstream task. However, manual prompts bring uncertainty in the model’s prediction, where a change in a single word drops the performance \[[247](https://arxiv.org/html/2307.06435v10#bib.bib247)\]. Prompt tuning alleviates this problem by fine-tuning only 0.001%-3% additional parameters \[[251](https://arxiv.org/html/2307.06435v10#bib.bib251)\]. It concatenates trainable prompt parameters with the model embeddings \[[247](https://arxiv.org/html/2307.06435v10#bib.bib247), [40](https://arxiv.org/html/2307.06435v10#bib.bib40), [251](https://arxiv.org/html/2307.06435v10#bib.bib251)\]. Task-specific fixed discrete prompts are concatenated with input embeddings in \[[40](https://arxiv.org/html/2307.06435v10#bib.bib40)\]. As discrete prompts bring instability, prompts are encoded through a learnable mapping in P-Tuning \[[247](https://arxiv.org/html/2307.06435v10#bib.bib247)\], naming continuous prompts, which are appended with the discrete prompts. Only the prompt encoder is trainable in the model. In an extension of P-Tuning, continuous prompts are concatenated with each layer of the network in \[[251](https://arxiv.org/html/2307.06435v10#bib.bib251)\]. Progressive prompts \[[252](https://arxiv.org/html/2307.06435v10#bib.bib252)\] avoid catastrophic forgetting and transfer previously learned knowledge by sequentially adding trainable prompt embeddings to the previously frozen task embeddings.

_Prefix Tuning:_ A set of trainable task-specific prefix vectors are appended to the frozen transformer layers in prefix tuning \[[41](https://arxiv.org/html/2307.06435v10#bib.bib41)\]. The prefix vectors are virtual tokens attended by the context tokens on the right. In addition, adaptive prefix tuning \[[253](https://arxiv.org/html/2307.06435v10#bib.bib253)\] applies a gating mechanism to control the information from the prefix and actual tokens.  
_Bias Tuning:_ Fine-tuning only bias terms in small to medium training data has been found effective in BitFit \[[254](https://arxiv.org/html/2307.06435v10#bib.bib254)\]. This method achieves full fine-tuning performance for tasks with less training data and comparable performance with more training data.

#### 3.6.2 Quantization

LLMs require extensive computing and memory for inference. Deploying a 175B parameter GPT-3 model needs at least five 80GB A100 GPUs and 350GB of memory to store in FP16 format \[[44](https://arxiv.org/html/2307.06435v10#bib.bib44)\]. Such demanding requirements for deploying LLMs make it harder for smaller organizations to utilize them. Model compression is an effective solution but comes at the cost of degraded performance, especially at large scales greater than 6B. These models exhibit very large magnitude outliers that do not exist in smaller models \[[255](https://arxiv.org/html/2307.06435v10#bib.bib255)\], making it challenging and requiring specialized methods for quantizing LLMs \[[44](https://arxiv.org/html/2307.06435v10#bib.bib44), [256](https://arxiv.org/html/2307.06435v10#bib.bib256)\].  
_Post-Training Quantization:_ Minimal or no training is required in this type of quantization, without significantly compromising the model performance. LLM-8-bit \[[255](https://arxiv.org/html/2307.06435v10#bib.bib255)\] uses full-precision matrix multiplication for weights associated with outlier features and 8-bit for remaining features. The lower precision multiplication outputs are converted to FP-16 and concatenated with others. The quantized models have homogenous word embeddings, which may degrade their performance. To fix this, token-level knowledge distillation is employed in \[[45](https://arxiv.org/html/2307.06435v10#bib.bib45)\] along with independent quantization scaling factors for each module due to varying weight distribution. Feature distributions are asymmetric and appear in different channels; outlier suppression \[[257](https://arxiv.org/html/2307.06435v10#bib.bib257)\] shifts and scales per-channel activation distributions for effective quantization. SmoothQuant \[[44](https://arxiv.org/html/2307.06435v10#bib.bib44)\] quantizes activations and weights to INT8 format by smoothing activations and migrating the quantization difficulty toward weights. It multiplies the inverse of the smoothing factor with weights, which introduces a few outliers in the weights but is easier to quantify than unsmoothed activations. OPTQ \[[256](https://arxiv.org/html/2307.06435v10#bib.bib256)\] uses the optimal brain compression (OBC) \[[258](https://arxiv.org/html/2307.06435v10#bib.bib258)\] algorithm to quantize the model layer-by-layer and update weights to compensate for quantization error. To improve speed and performance, OPTQ updates weights in arbitrary order, employs lazy updates, and uses better Cholesky kernels. Outlier-aware weight quantization (OWQ) \[[259](https://arxiv.org/html/2307.06435v10#bib.bib259)\] uses the OPTQ algorithm for quantization but assigns higher precision to vulnerable weights, causing outliers and lower precision for others.  
_Quantization-Aware Training:_ To compensate for performance degradation, a quantized model is fine-tuned in quantization-aware training (QAT) \[[260](https://arxiv.org/html/2307.06435v10#bib.bib260), [261](https://arxiv.org/html/2307.06435v10#bib.bib261), [262](https://arxiv.org/html/2307.06435v10#bib.bib262)\]. Alpha Tuning quantizes the model using binary coding quantization (BCQ) \[[263](https://arxiv.org/html/2307.06435v10#bib.bib263)\] and fine-tunes only quantization scaling factors. This approach improves performance over parameter-efficient fine-tuning of the pre-trained model. Similarly, parameter-efficient and quantization-aware adaptation (PEQA) \[[264](https://arxiv.org/html/2307.06435v10#bib.bib264)\] reduces the precision of fully-connected layers and fine-tunes only quantization scaling parameters. LLM-QAT \[[262](https://arxiv.org/html/2307.06435v10#bib.bib262)\] generates training data from the pre-trained network and trains a quantized student model with knowledge distillation. QLoRA \[[261](https://arxiv.org/html/2307.06435v10#bib.bib261)\] fine-tunes 4-bit quantized pre-trained LLM with LoRA \[[250](https://arxiv.org/html/2307.06435v10#bib.bib250)\] using a 4-bit normal float, which shows better performance over a 4-bit integer and float.

#### 3.6.3 Pruning

Pruning is an alternative approach to quantization to compress model size, thereby reducing LLMs deployment costs significantly. Compared to task-agnostic pruning, task-specific pruning is easily achievable with good performance, where a model is fine-tuned on the downstream task and pruned for faster inference. It is possible to prune LLMs for individual tasks, but the cost of pruning and deploying task-specific models is high. To overcome this, many structured and unstructured pruning methods for LLMs have been proposed to maintain reasonable performance across all tasks while shrinking the model size \[[265](https://arxiv.org/html/2307.06435v10#bib.bib265), [42](https://arxiv.org/html/2307.06435v10#bib.bib42), [266](https://arxiv.org/html/2307.06435v10#bib.bib266)\].  
_Unstructured Pruning:_ This kind of pruning removes less important weights without maintaining any structure. Existing LLM pruning methods take advantage of the unique characteristics of LLMs, uncommon for smaller models, where a small subset of hidden states are activated with large magnitude \[[255](https://arxiv.org/html/2307.06435v10#bib.bib255)\]. Pruning by weights and activations (Wanda) \[[265](https://arxiv.org/html/2307.06435v10#bib.bib265)\] prunes weights in every row based on importance, calculated by multiplying the weights with the norm of input. The pruned model does not require fine-tuning, thereby saving computational costs. Outlier weighed layerwise sparsity (OWL) \[[267](https://arxiv.org/html/2307.06435v10#bib.bib267)\] extends Wanda with non-uniform layer pruning. It shows that the number of outliers varies for different layers; therefore, the model should have variable pruning ratios for better performance for every layer. Contrastive pruning (CAP) \[[43](https://arxiv.org/html/2307.06435v10#bib.bib43)\] iteratively prunes the model by training the sparse model using contrastive loss between pre-trained, fine-tuned, and snapshots of previous sparse models to learn task-specific and task-agnostic knowledge.  
_Structured Pruning:_ Here, the parameters are removed in groups, rows, columns, or matrices, which speeds up the inference because of effective hardware tensor core utilization \[[265](https://arxiv.org/html/2307.06435v10#bib.bib265)\]. LLM-Pruner \[[42](https://arxiv.org/html/2307.06435v10#bib.bib42)\] employs a 3-stage structured pruning strategy, identifying the groups of hidden states causing each other to activate during the forward-pass, keeping important groups and removing less important ones, and fine-tuning the pruned model with LoRA. Sparsity-induced mask learning (SIMPLE) \[[268](https://arxiv.org/html/2307.06435v10#bib.bib268)\] prunes the network using learnable masks. Similarly, another method prunes LLMs by learning masks and removing unimportant rank-1 components of the factorized weight matrix \[[266](https://arxiv.org/html/2307.06435v10#bib.bib266)\].

### 3.7 Multimodal LLMs

Inspired by the success of LLMs in natural language processing applications, an increasing number of research works are now facilitating LLMs to perceive different modalities of information like image \[[269](https://arxiv.org/html/2307.06435v10#bib.bib269), [270](https://arxiv.org/html/2307.06435v10#bib.bib270), [271](https://arxiv.org/html/2307.06435v10#bib.bib271)\], video \[[272](https://arxiv.org/html/2307.06435v10#bib.bib272), [273](https://arxiv.org/html/2307.06435v10#bib.bib273), [274](https://arxiv.org/html/2307.06435v10#bib.bib274)\], audio \[[275](https://arxiv.org/html/2307.06435v10#bib.bib275), [274](https://arxiv.org/html/2307.06435v10#bib.bib274), [276](https://arxiv.org/html/2307.06435v10#bib.bib276)\], etc. Multimodal LLMs (MLLMs) present substantial benefits compared to standard LLMs that process only text. By incorporating information from various modalities, MLLMs can achieve a deeper understanding of context, leading to more intelligent responses infused with a variety of expressions. Importantly, MLLMs align closely with human perceptual experiences, leveraging the synergistic nature of our multisensory inputs to form a comprehensive understanding of the world \[[276](https://arxiv.org/html/2307.06435v10#bib.bib276), [26](https://arxiv.org/html/2307.06435v10#bib.bib26)\]. Coupled with a user-friendly interface, MLLMs can offer intuitive, flexible, and adaptable interactions, allowing users to engage with intelligent assistants through a spectrum of input methods. According to the ways of constructing models, current MLLMs can be generally divided into three streams: pre-training, fine-tuning, and prompting. In this section, we will discuss more details of these main streams, as well as the important application of MLLMs in visual reasoning.  
_Pre-training:_ This stream of MLLMs intends to support different modalities using unified end-to-end models. For instance, Flamingo \[[269](https://arxiv.org/html/2307.06435v10#bib.bib269)\] applies gated cross-attention to fuse vision and language modalities, which are collected from pre-trained and frozen visual encoder and LLM, respectively. Moreover, BLIP-2 \[[270](https://arxiv.org/html/2307.06435v10#bib.bib270)\] proposes a two-stage strategy to pre-train a Querying Transformer (Q-Former) for the alignment between vision and language modalities: in the first stage, vision-language representation learning is bootstrapped from a frozen visual encoder; and in the second stage, a frozen LLM bootstraps vision-to-language generative learning for zero-shot image-to-text generation. Similarly, MiniGPT-4 \[[277](https://arxiv.org/html/2307.06435v10#bib.bib277)\] deploys pre-trained and frozen ViT \[[278](https://arxiv.org/html/2307.06435v10#bib.bib278)\], Q-Former and Vicuna LLM \[[159](https://arxiv.org/html/2307.06435v10#bib.bib159)\], only training the linear projection layer for vision and language modalities alignment.  
_Fine-tuning:_ Derived from instruction tuning \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16)\] for NLP tasks \[[20](https://arxiv.org/html/2307.06435v10#bib.bib20), [16](https://arxiv.org/html/2307.06435v10#bib.bib16), [97](https://arxiv.org/html/2307.06435v10#bib.bib97)\], researchers are fine-tune pre-trained LLMs using multimodal instructions. Following this method, LLMs can be easily and effectively extended as multimodal chatbots \[[277](https://arxiv.org/html/2307.06435v10#bib.bib277), [271](https://arxiv.org/html/2307.06435v10#bib.bib271), [29](https://arxiv.org/html/2307.06435v10#bib.bib29)\] and multimodal task solvers \[[279](https://arxiv.org/html/2307.06435v10#bib.bib279), [30](https://arxiv.org/html/2307.06435v10#bib.bib30), [280](https://arxiv.org/html/2307.06435v10#bib.bib280)\]. The key issue of this stream of MLLMs is to collect multimodal instruction-following data for fine-tuning \[[58](https://arxiv.org/html/2307.06435v10#bib.bib58)\]. To address this issue, the solutions of benchmark adaptation \[[279](https://arxiv.org/html/2307.06435v10#bib.bib279), [281](https://arxiv.org/html/2307.06435v10#bib.bib281), [282](https://arxiv.org/html/2307.06435v10#bib.bib282)\], self-instruction \[[19](https://arxiv.org/html/2307.06435v10#bib.bib19), [31](https://arxiv.org/html/2307.06435v10#bib.bib31), [283](https://arxiv.org/html/2307.06435v10#bib.bib283)\], and hybrid composition \[[284](https://arxiv.org/html/2307.06435v10#bib.bib284), [280](https://arxiv.org/html/2307.06435v10#bib.bib280)\] are employed, respectively. To mitigate the gap between the original language modality and additional modalities, the learnable interface is introduced to connect different modalities from frozen pre-trained models. Particularly, the learnable interface is expected to work in a parameter-efficient tuning manner: e.g., LLaMA-Adapter \[[285](https://arxiv.org/html/2307.06435v10#bib.bib285)\] applies an efficient transformer-based adapter module for training, and LaVIN \[[284](https://arxiv.org/html/2307.06435v10#bib.bib284)\] dynamically learns the multimodal feature weights using a mixture-of-modality adapter. Different from the learnable interface, the expert models can directly convert multimodalities into language: e.g., VideoChat-Text \[[272](https://arxiv.org/html/2307.06435v10#bib.bib272)\] incorporates Whisper \[[286](https://arxiv.org/html/2307.06435v10#bib.bib286)\], a speech recognition expert model, to generate the captions of given videos for the understanding of following LLMs.  
_Prompting:_ Different from the fine-tuning technique that directly updates the model parameters given task-specific datasets, the prompting technique provides certain context, examples, or instructions to the model, fulfilling specialized tasks without changing the model parameters. Since prompting can significantly reduce the need for large-scale multimodal data, this technique is widely used to construct MLLMs. Particularly, to solve multimodal Chain of Thought (CoT) problems \[[103](https://arxiv.org/html/2307.06435v10#bib.bib103)\], LLMs are prompted to generate both the reasoning process and the answer given multimodal inputs \[[287](https://arxiv.org/html/2307.06435v10#bib.bib287)\]. On this front, different learning paradigms are exploited in practice: for example, Multimodal-CoT \[[287](https://arxiv.org/html/2307.06435v10#bib.bib287)\] involves two stages of rationale generation and answer inference, where the input of the second stage is a combination of the original input and the output of the first stage; and CoT-PT \[[288](https://arxiv.org/html/2307.06435v10#bib.bib288)\] applies both prompt tuning and specific visual bias to generate a chain of reasoning implicitly. In addition to CoT problems, LLMs can also be prompted with multimodal descriptions and tools, effectively dividing complex tasks into sub-tasks \[[289](https://arxiv.org/html/2307.06435v10#bib.bib289), [290](https://arxiv.org/html/2307.06435v10#bib.bib290)\].  
_Visual Reasoning Application:_ Recent visual reasoning systems \[[291](https://arxiv.org/html/2307.06435v10#bib.bib291), [292](https://arxiv.org/html/2307.06435v10#bib.bib292), [216](https://arxiv.org/html/2307.06435v10#bib.bib216), [293](https://arxiv.org/html/2307.06435v10#bib.bib293)\] tend to apply LLMs for better visual information analysis and visual-language integration. Different from previous works \[[294](https://arxiv.org/html/2307.06435v10#bib.bib294), [295](https://arxiv.org/html/2307.06435v10#bib.bib295)\] that rely on limited VQA datasets and small-scale neural networks, current LLM-aided methods offer benefits of stronger generalization ability, emergent ability, and interactivity \[[58](https://arxiv.org/html/2307.06435v10#bib.bib58)\]. To realize visual reasoning with the help of LLMs, prompting and fine-tuning techniques can also be utilized: for example, PointClip V2 \[[292](https://arxiv.org/html/2307.06435v10#bib.bib292)\] applies LLMs to generate 3D-specific prompts, which are encoded as textual features and then combined with visual features for 3D recognition; and GPT4Tools \[[31](https://arxiv.org/html/2307.06435v10#bib.bib31)\] employs LoRA \[[250](https://arxiv.org/html/2307.06435v10#bib.bib250)\] to fine-tune LLMs following tool-related instructions. Serving as a controller \[[293](https://arxiv.org/html/2307.06435v10#bib.bib293)\], decision maker \[[296](https://arxiv.org/html/2307.06435v10#bib.bib296)\], or semantics refiner \[[291](https://arxiv.org/html/2307.06435v10#bib.bib291), [297](https://arxiv.org/html/2307.06435v10#bib.bib297)\], LLMs significantly facilitates the progress of visual reasoning research.

### 3.8 Summary and Discussion

#### 3.8.1 Architecture

Due to the gigantic scale of LLMs, minor changes in architecture and training strategies have a big impact on performance and stability. Here, we summarize key architectural modules used in various LLMs, leading to better performance, reduced training time and memory, and better training stability.  
_Layer Normalization:_ The performance and training stability of LLMs are affected significantly by layer normalization. Pre-norm, that is normalizing inputs rather than outputs, is more common among LLMs stabilizing the training \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6), [127](https://arxiv.org/html/2307.06435v10#bib.bib127), [108](https://arxiv.org/html/2307.06435v10#bib.bib108)\]. BLOOM \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\] and AlexaTM \[[122](https://arxiv.org/html/2307.06435v10#bib.bib122)\] utilize an additional layer normalization before embedding layer to stabilize the training of large-scale models, while the model’s zero-shot generalization ability can be negatively impacted \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\]. However, another study \[[33](https://arxiv.org/html/2307.06435v10#bib.bib33)\] finds that pre-norm degrades fine-tuned model performance as compared to post-norm, and there are no stability benefits of pre-norm beyond the 100B scale. Therefore, GLM-130B \[[33](https://arxiv.org/html/2307.06435v10#bib.bib33)\] used deep-norm which is a variant of post-norm for better downstream task performance after fine-tuning.  
_Positional Encoding:_ Like other building blocks of the model, positional encoding also affects the performance and training stability of LLMs. BLOOM \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\] finds ALiBi outperforms learned and rotary positional encodings. Contrary to this, GLM-130B \[[33](https://arxiv.org/html/2307.06435v10#bib.bib33)\] identifies rotary positional encoding as being better than ALiBi. So, there is no conclusion in the literature about positional encodings yet.  
_Parallel Attention:_ In this type of attention, feed-forward and attention layers are parallel to each other rather than sequential in a transformer block. It has been shown to reduce training time by 15%. There is no evidence of performance drop due to this change in the literature and it is used by the models PaLM \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15)\], GPT-NeoX \[[118](https://arxiv.org/html/2307.06435v10#bib.bib118)\], and CodeGen \[[140](https://arxiv.org/html/2307.06435v10#bib.bib140)\].  
_Multi-Query Attention_ It has shared key and value attention heads in a transformer block while query attention heads are projected as usual. This reduces memory usage and speeds up sampling in autoregressive decoding. No performance degradation has been observed with this change and it makes the training efficient allowing larger batch sizes. Multi-query attention is used in \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15), [142](https://arxiv.org/html/2307.06435v10#bib.bib142)\].  
_Mixture of Experts:_ This type of architecture enables easily scaling models to trillions of parameters \[[92](https://arxiv.org/html/2307.06435v10#bib.bib92), [91](https://arxiv.org/html/2307.06435v10#bib.bib91)\]. Only a few experts are activated during the computation making them compute-efficient. The performance of MoE models is better than dense models for the same amount of data and requires less computation during fine-tuning to achieve performance similar to dense models as discussed in \[[91](https://arxiv.org/html/2307.06435v10#bib.bib91)\]. MoE architectures are less prone to catastrophic forgetting, therefore are more suited for continual learning \[[92](https://arxiv.org/html/2307.06435v10#bib.bib92)\]. Extracting smaller sub-models for downstream tasks is possible without losing any performance, making MoE architecture hardware-friendly \[[92](https://arxiv.org/html/2307.06435v10#bib.bib92)\].  
_Sparse vs Dense Activated:_ GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\] uses sparse transformers \[[67](https://arxiv.org/html/2307.06435v10#bib.bib67)\] whereas GLaM \[[91](https://arxiv.org/html/2307.06435v10#bib.bib91)\] and PanGu-∑\\sum∑ \[[92](https://arxiv.org/html/2307.06435v10#bib.bib92)\] use MoE \[[121](https://arxiv.org/html/2307.06435v10#bib.bib121)\] architectures to lower computational costs and increase the model size and capacity. According to the literature, sparse modules do not degrade the model’s performance \[[67](https://arxiv.org/html/2307.06435v10#bib.bib67)\]. However, more experiments are required to verify this statement.

#### 3.8.2 Training Strategies

Training models at a huge scale require tricks to reduce training costs, avoid loss divergence, and achieve better performance. We summarize and discuss some of these key tricks used in different LLMs.  
_Mixed Precision:_ It is a famous method for LLMs to reduce memory usage and improve training efficiency. In mixed precision, forward and backward passes are performed in FP16 format whereas optimizer states and master weights are kept in FP32 format \[[120](https://arxiv.org/html/2307.06435v10#bib.bib120)\]. A drawback associated with this format change is training instability due to a smaller value range resulting in loss spikes \[[33](https://arxiv.org/html/2307.06435v10#bib.bib33)\]. An alternative to FP16 is BF16 which has a comparatively larger range and performs precision-sensitive operations like gradient accumulation and softmax in FP32 \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\]. BF16 has better performance and training stability but uses more memory and is supported on specific hardware, for example, A100 GPUs. Therefore, its adoption in LLMs is limited.  
_Training Instability:_ Loss divergence or spiking is a common issue in LLMs that occurs multiple times during training. This happens in the presence of gradient clipping \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15)\]. To mitigate this problem, many approaches suggest restarting training from an earlier checkpoint \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15), [33](https://arxiv.org/html/2307.06435v10#bib.bib33), [91](https://arxiv.org/html/2307.06435v10#bib.bib91)\], skipping 200-500 earlier data batches at the point of divergence in \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15)\] and re-shuffling batches in \[[91](https://arxiv.org/html/2307.06435v10#bib.bib91)\]. The embedding layer gradient shrink proves to further stabilize the training as its gradient norm is significantly larger than the other layers \[[33](https://arxiv.org/html/2307.06435v10#bib.bib33)\]. Another suggestion to improve training stability for larger models is not to use biases in dense and norm layers as in \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15)\].  
_Weight Initialization:_ It plays a significant role in model convergence and training stability. GPT-NeoX \[[118](https://arxiv.org/html/2307.06435v10#bib.bib118)\] initializes feed-forward layers before residuals with 2L⁢d2𝐿𝑑\\frac{2}{L\\sqrt{d}}divide start\_ARG 2 end\_ARG start\_ARG italic\_L square-root start\_ARG italic\_d end\_ARG end\_ARG as in \[[153](https://arxiv.org/html/2307.06435v10#bib.bib153)\] and other layers with the small initialization scheme \[[298](https://arxiv.org/html/2307.06435v10#bib.bib298)\]. This avoids activations growing exponentially with increasing depth. MT-NLG \[[117](https://arxiv.org/html/2307.06435v10#bib.bib117)\] found higher variance for weight initialization leads to unstable training, hence validating small initialization scheme \[[298](https://arxiv.org/html/2307.06435v10#bib.bib298)\]. Various models perform random weight initialization which can cause bad initialization, Galactica \[[148](https://arxiv.org/html/2307.06435v10#bib.bib148)\] suggests a longer warmup to negate the effect.  
_Learning Rate:_ A suitable learning rate is important for stable training. It is suggested to use a lower value \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13), [15](https://arxiv.org/html/2307.06435v10#bib.bib15), [124](https://arxiv.org/html/2307.06435v10#bib.bib124)\] with warmup and decay (cosine or linear). Usually, the learning rate is within the range 1⁢e−41superscript𝑒41e^{-4}1 italic\_e start\_POSTSUPERSCRIPT - 4 end\_POSTSUPERSCRIPT to 8⁢e−48superscript𝑒48e^{-4}8 italic\_e start\_POSTSUPERSCRIPT - 4 end\_POSTSUPERSCRIPT. Moreover, MT-NLG (530B) \[[117](https://arxiv.org/html/2307.06435v10#bib.bib117)\] and GPT-NeoX (20B) \[[118](https://arxiv.org/html/2307.06435v10#bib.bib118)\] suggest interpolating learning rates based on the model size using the GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\] models ranging between 13B and 175B. This avoids tuning the learning rate hyperparameter.  
_Training Parallelism:_ 3D parallelism, a combination of data, pipeline, and tensor parallelism, is the most utilized training parallelism approach in LLMs \[[33](https://arxiv.org/html/2307.06435v10#bib.bib33), [15](https://arxiv.org/html/2307.06435v10#bib.bib15), [14](https://arxiv.org/html/2307.06435v10#bib.bib14), [13](https://arxiv.org/html/2307.06435v10#bib.bib13), [117](https://arxiv.org/html/2307.06435v10#bib.bib117), [115](https://arxiv.org/html/2307.06435v10#bib.bib115), [112](https://arxiv.org/html/2307.06435v10#bib.bib112)\]. In addition to 3D parallelism, BLOOM \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\] uses a zero optimizer \[[37](https://arxiv.org/html/2307.06435v10#bib.bib37)\] to shard optimizer states. PanGu-α𝛼\\alphaitalic\_α \[[108](https://arxiv.org/html/2307.06435v10#bib.bib108)\] and PanGu-ΣΣ\\Sigmaroman\_Σ \[[92](https://arxiv.org/html/2307.06435v10#bib.bib92)\] go beyond 3D parallelism and apply 5D parallelism which additionally contains optimizer parallelism and rematerialization.  
_Mode Switching:_ It adds task-related tokens at the beginning of the text during training. These tokens refer to the natural language understanding and natural language generation tasks which are shown to improve downstream task performance in \[[125](https://arxiv.org/html/2307.06435v10#bib.bib125), [124](https://arxiv.org/html/2307.06435v10#bib.bib124), [122](https://arxiv.org/html/2307.06435v10#bib.bib122)\]. During fine-tuning and inference, tokens are appended based on the downstream tasks.  
_Controllable Text Generation:_ Generating credible and controlled text from a pre-trained model is challenging. GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\] and other LLMs use in-context learning to control generated text. While in-context learning helps in controlling the generated text, ERNIE 3.0 Titan \[[35](https://arxiv.org/html/2307.06435v10#bib.bib35)\] suggests using adversarial loss to rank its generated text for credibility and soft prompts such as genre, topic, keywords, sentiment, and length for better control on generated text.

#### 3.8.3 Supervised Models vs Generalized Models

Although generalized models are capable of performing diverse tasks with good performance they have not yet outperformed models trained in supervised settings. The supervised trained models are still state-of-the-art in various NLP tasks by a large margin as shown in \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6), [15](https://arxiv.org/html/2307.06435v10#bib.bib15), [18](https://arxiv.org/html/2307.06435v10#bib.bib18)\].

#### 3.8.4 Zero-Shot vs Few-Shot

LLMs perform well in zero-shot and few-shot settings. But the performance difference between zero-shot and few-shot is large for pre-trained models \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6), [15](https://arxiv.org/html/2307.06435v10#bib.bib15)\], naming LLMs as meta-learners \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\]. LLMs zero-shot evaluations underperform unsupervised methods in neural machine translation \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\]. The literature shows pre-training is not enough for good zero-shot performance \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15), [16](https://arxiv.org/html/2307.06435v10#bib.bib16)\]. To improve the zero-shot performance the literature suggests using instruction fine-tuning that improves the zero-shot performance significantly and outperforms baselines. Instruction fine-tuning has also been shown to improve zero-shot generalization to unseen tasks. Another model, Flan-PaLM \[[16](https://arxiv.org/html/2307.06435v10#bib.bib16)\], unlocks zero-shot reasoning with CoT training.

#### 3.8.5 Encoder vs Decoder vs Encoder-Decoder

Traditionally, these architectures perform well for different tasks, for example, encoder-only for NLU tasks, decoder-only for NLG, and encoder-decoder for sequence2sequence modeling. Encoder-only models are famous for smaller models such as Bert \[[7](https://arxiv.org/html/2307.06435v10#bib.bib7)\], RoBERTa \[[299](https://arxiv.org/html/2307.06435v10#bib.bib299)\], etc., whereas LLMs are either decoder-only \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6), [118](https://arxiv.org/html/2307.06435v10#bib.bib118), [13](https://arxiv.org/html/2307.06435v10#bib.bib13)\] or encoder-decoder \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10), [11](https://arxiv.org/html/2307.06435v10#bib.bib11), [122](https://arxiv.org/html/2307.06435v10#bib.bib122)\]. While decoder-only models are good at NLG tasks, various LLMs, PaLM \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15)\], OPT \[[14](https://arxiv.org/html/2307.06435v10#bib.bib14)\], GPT-3 \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6)\], BLOOM \[[13](https://arxiv.org/html/2307.06435v10#bib.bib13)\], LLaMA \[[156](https://arxiv.org/html/2307.06435v10#bib.bib156)\], are decoder-only models with significant performance gains on both NLU and NLG tasks. In contradiction to this, T5 \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\] and UL2 \[[125](https://arxiv.org/html/2307.06435v10#bib.bib125)\] identify encoder-decoder models out-performing decoder-only models. In another study, PaLM \[[15](https://arxiv.org/html/2307.06435v10#bib.bib15)\] finds increasing the size of decoder-only models can reduce the performance gap between decoder-only and encoder-decoder architectures.  
Although decoder-only architectures have become a trend for LLMs, many recently proposed approaches \[[125](https://arxiv.org/html/2307.06435v10#bib.bib125), [122](https://arxiv.org/html/2307.06435v10#bib.bib122)\] use mode-switching tokens in text with encoder-decoder architectures to enable task-specific modes. Similarly, CodeT5+ \[[34](https://arxiv.org/html/2307.06435v10#bib.bib34)\] uses an encoder-decoder architecture with multiple training objectives for different tasks, activating the encoder, decoder, or both according to the tasks. These variations in architecture and training objectives allow a model to perform well in different settings. Because of this dynamic configuration, the future of LLMs can be attributed to encoder-decoder architectures.

## 5 Datasets and Evaluation

Generating training and evaluation datasets is expensive because of the large-scale data demand of LLMs. Hence, datasets for training and benchmarking these models are topics of key importance. A summary of datasets commonly used by LLMs is provided next.

### 5.1 Training Datasets

The performance of LLMs largely depends on the training data’s quality, size, and diversity. Preparing training datasets of high quality at a large scale is laborious. Researchers have suggested various pre-training and fine-tuning datasets to enhance LLMs capabilities. We summarize these efforts in Table [8](https://arxiv.org/html/2307.06435v10#S5.T8 "Table 8 ‣ 5.2 Evaluation Datasets and Tasks ‣ 5 Datasets and Evaluation ‣ A Comprehensive Overview of Large Language Models"). While numerous training datasets are available in the literature, we cover the most widely used ones in our summary.

### 5.2 Evaluation Datasets and Tasks

The evaluation of LLMs is important in gauging their proficiency and limitations. This process measures the model’s ability to comprehend, generate, and interact with human language across a spectrum of tasks. Evaluating a language model (LM) is divided into two broader categories: 1) natural language understanding (NLU) and 2) natural language generation (NLG). It is emphasized that tasks in NLU and NLG are softly categorized and are often used interchangeably in the literature.  
  _Natural Language Understanding:_ It measures the language understanding capacity of LMs. It encompasses multiple tasks, including sentiment analysis, text classification, natural language inference (NLI), question answering (QA), commonsense reasoning (CR), mathematical reasoning (MR), reading comprehension (RC), etc.  
  _Natural Language Generation:_ It assesses the language generation capabilities of LLMs by understanding the provided input context. It includes tasks such as summarization, sentence completion, machine translation (MT), dialogue generation, etc.  
Numerous datasets are proposed for each task, evaluating LLMs against different characteristics. To provide an overview of evaluation datasets, we briefly discuss a few famous datasets within each category and offer a comprehensive list of datasets in Table [9](https://arxiv.org/html/2307.06435v10#S5.T9 "Table 9 ‣ 5.2 Evaluation Datasets and Tasks ‣ 5 Datasets and Evaluation ‣ A Comprehensive Overview of Large Language Models"). Moreover, we show a detailed overview of the training datasets and evaluation tasks and benchmarks used by various pre-trained LLMs in Table [10](https://arxiv.org/html/2307.06435v10#S5.T10 "Table 10 ‣ 5.2 Evaluation Datasets and Tasks ‣ 5 Datasets and Evaluation ‣ A Comprehensive Overview of Large Language Models") and fine-tuned LLMs in Table [11](https://arxiv.org/html/2307.06435v10#S5.T11 "Table 11 ‣ 5.2 Evaluation Datasets and Tasks ‣ 5 Datasets and Evaluation ‣ A Comprehensive Overview of Large Language Models"). We also compare the top-performing LLMs in various NLP tasks in Table [12](https://arxiv.org/html/2307.06435v10#S5.T12 "Table 12 ‣ 5.2.12 Biases and Ethics in AI ‣ 5.2 Evaluation Datasets and Tasks ‣ 5 Datasets and Evaluation ‣ A Comprehensive Overview of Large Language Models").

Multi-Task

MMLU \[[307](https://arxiv.org/html/2307.06435v10#bib.bib307)\], SuperGLUE \[[2](https://arxiv.org/html/2307.06435v10#bib.bib2)\], BIG-bench \[[308](https://arxiv.org/html/2307.06435v10#bib.bib308)\], GLUE \[[309](https://arxiv.org/html/2307.06435v10#bib.bib309)\], BBH \[[308](https://arxiv.org/html/2307.06435v10#bib.bib308)\], CUGE \[[310](https://arxiv.org/html/2307.06435v10#bib.bib310)\], ZeroCLUE \[[311](https://arxiv.org/html/2307.06435v10#bib.bib311)\], FewCLUE \[[312](https://arxiv.org/html/2307.06435v10#bib.bib312)\], Blended Skill Talk \[[313](https://arxiv.org/html/2307.06435v10#bib.bib313)\], HELM \[[314](https://arxiv.org/html/2307.06435v10#bib.bib314)\], KLUE-STS \[[315](https://arxiv.org/html/2307.06435v10#bib.bib315)\]

Language Understanding

CoQA \[[316](https://arxiv.org/html/2307.06435v10#bib.bib316)\], WiC \[[317](https://arxiv.org/html/2307.06435v10#bib.bib317)\], Wikitext103 \[[318](https://arxiv.org/html/2307.06435v10#bib.bib318)\], PG19 \[[319](https://arxiv.org/html/2307.06435v10#bib.bib319)\], LCQMC \[[320](https://arxiv.org/html/2307.06435v10#bib.bib320)\], QQP \[[321](https://arxiv.org/html/2307.06435v10#bib.bib321)\], WinoGender \[[322](https://arxiv.org/html/2307.06435v10#bib.bib322)\], CB \[[323](https://arxiv.org/html/2307.06435v10#bib.bib323)\], FinRE \[[324](https://arxiv.org/html/2307.06435v10#bib.bib324)\], SanWen \[[325](https://arxiv.org/html/2307.06435v10#bib.bib325)\], AFQMC \[[311](https://arxiv.org/html/2307.06435v10#bib.bib311)\], BQ Corpus \[[326](https://arxiv.org/html/2307.06435v10#bib.bib326)\], CNSS \[[327](https://arxiv.org/html/2307.06435v10#bib.bib327)\], CKBQA 13 \[[328](https://arxiv.org/html/2307.06435v10#bib.bib328)\], CLUENER \[[311](https://arxiv.org/html/2307.06435v10#bib.bib311)\], Weibo \[[329](https://arxiv.org/html/2307.06435v10#bib.bib329)\], AQuA \[[330](https://arxiv.org/html/2307.06435v10#bib.bib330)\], OntoNotes \[[331](https://arxiv.org/html/2307.06435v10#bib.bib331)\], HeadQA \[[332](https://arxiv.org/html/2307.06435v10#bib.bib332)\], Twitter Dataset \[[333](https://arxiv.org/html/2307.06435v10#bib.bib333)\]

Story Cloze and

Sentence Completion

StoryCloze \[[334](https://arxiv.org/html/2307.06435v10#bib.bib334)\], LAMBADA \[[335](https://arxiv.org/html/2307.06435v10#bib.bib335)\], LCSTS \[[336](https://arxiv.org/html/2307.06435v10#bib.bib336)\], AdGen \[[337](https://arxiv.org/html/2307.06435v10#bib.bib337)\], E2E \[[338](https://arxiv.org/html/2307.06435v10#bib.bib338)\], CHID \[[339](https://arxiv.org/html/2307.06435v10#bib.bib339)\], CHID-FC \[[312](https://arxiv.org/html/2307.06435v10#bib.bib312)\]

Physical Knowledge and

World Understanding

PIQA \[[340](https://arxiv.org/html/2307.06435v10#bib.bib340)\], TriviaQA \[[341](https://arxiv.org/html/2307.06435v10#bib.bib341)\], ARC \[[342](https://arxiv.org/html/2307.06435v10#bib.bib342)\], ARC-Easy \[[342](https://arxiv.org/html/2307.06435v10#bib.bib342)\], ARC-Challenge \[[342](https://arxiv.org/html/2307.06435v10#bib.bib342)\], PROST \[[343](https://arxiv.org/html/2307.06435v10#bib.bib343)\], OpenBookQA \[[344](https://arxiv.org/html/2307.06435v10#bib.bib344)\], WebNLG \[[345](https://arxiv.org/html/2307.06435v10#bib.bib345)\], DogWhistle Insider & Outsider \[[346](https://arxiv.org/html/2307.06435v10#bib.bib346)\]

Contextual Language

Understanding

RACE \[[347](https://arxiv.org/html/2307.06435v10#bib.bib347)\], RACE-Middle \[[347](https://arxiv.org/html/2307.06435v10#bib.bib347)\], RACE-High \[[347](https://arxiv.org/html/2307.06435v10#bib.bib347)\], QuAC \[[348](https://arxiv.org/html/2307.06435v10#bib.bib348)\], StrategyQA \[[349](https://arxiv.org/html/2307.06435v10#bib.bib349)\], Quiz Bowl \[[350](https://arxiv.org/html/2307.06435v10#bib.bib350)\], cMedQA \[[351](https://arxiv.org/html/2307.06435v10#bib.bib351)\],cMedQA2 \[[352](https://arxiv.org/html/2307.06435v10#bib.bib352)\], MATINF-QA \[[353](https://arxiv.org/html/2307.06435v10#bib.bib353)\]

Commonsense Reasoning

WinoGrande \[[354](https://arxiv.org/html/2307.06435v10#bib.bib354)\], HellaSwag \[[355](https://arxiv.org/html/2307.06435v10#bib.bib355)\], COPA \[[356](https://arxiv.org/html/2307.06435v10#bib.bib356)\], WSC \[[357](https://arxiv.org/html/2307.06435v10#bib.bib357)\], CSQA \[[358](https://arxiv.org/html/2307.06435v10#bib.bib358)\], SIQA \[[359](https://arxiv.org/html/2307.06435v10#bib.bib359)\], C3 \[[360](https://arxiv.org/html/2307.06435v10#bib.bib360)\], CLUEWSC2020 \[[311](https://arxiv.org/html/2307.06435v10#bib.bib311)\], CLUEWSC \[[311](https://arxiv.org/html/2307.06435v10#bib.bib311)\], CLUEWSC-FC \[[312](https://arxiv.org/html/2307.06435v10#bib.bib312)\], ReCoRD \[[361](https://arxiv.org/html/2307.06435v10#bib.bib361)\]

Reading Comprehension

SQuAD \[[362](https://arxiv.org/html/2307.06435v10#bib.bib362)\], BoolQ \[[363](https://arxiv.org/html/2307.06435v10#bib.bib363)\], SQUADv2 \[[364](https://arxiv.org/html/2307.06435v10#bib.bib364)\], DROP \[[365](https://arxiv.org/html/2307.06435v10#bib.bib365)\], RTE \[[366](https://arxiv.org/html/2307.06435v10#bib.bib366)\], WebQA \[[367](https://arxiv.org/html/2307.06435v10#bib.bib367)\], CMRC2017 \[[368](https://arxiv.org/html/2307.06435v10#bib.bib368)\], CMRC2018 \[[369](https://arxiv.org/html/2307.06435v10#bib.bib369)\], CMRC2019 \[[370](https://arxiv.org/html/2307.06435v10#bib.bib370)\], COTE-BD \[[371](https://arxiv.org/html/2307.06435v10#bib.bib371)\], COTE-DP \[[371](https://arxiv.org/html/2307.06435v10#bib.bib371)\], COTE-MFW \[[371](https://arxiv.org/html/2307.06435v10#bib.bib371)\], MultiRC \[[372](https://arxiv.org/html/2307.06435v10#bib.bib372)\], Natural Questions \[[373](https://arxiv.org/html/2307.06435v10#bib.bib373)\], CNSE \[[327](https://arxiv.org/html/2307.06435v10#bib.bib327)\], DRCD \[[374](https://arxiv.org/html/2307.06435v10#bib.bib374)\], DuReader \[[375](https://arxiv.org/html/2307.06435v10#bib.bib375)\], Dureaderrobust \[[376](https://arxiv.org/html/2307.06435v10#bib.bib376)\], DuReader-QG \[[375](https://arxiv.org/html/2307.06435v10#bib.bib375)\], SciQ \[[377](https://arxiv.org/html/2307.06435v10#bib.bib377)\], Sogou-log \[[378](https://arxiv.org/html/2307.06435v10#bib.bib378)\], Dureaderrobust\-QG \[[376](https://arxiv.org/html/2307.06435v10#bib.bib376)\], QA4MRE \[[379](https://arxiv.org/html/2307.06435v10#bib.bib379)\], KorQuAD 1.0 \[[380](https://arxiv.org/html/2307.06435v10#bib.bib380)\], CAIL2018-Task1 & Task2 \[[381](https://arxiv.org/html/2307.06435v10#bib.bib381)\]

Mathematical Reasoning

MATH \[[382](https://arxiv.org/html/2307.06435v10#bib.bib382)\], Math23k \[[383](https://arxiv.org/html/2307.06435v10#bib.bib383)\], GSM8K \[[384](https://arxiv.org/html/2307.06435v10#bib.bib384)\], MathQA \[[385](https://arxiv.org/html/2307.06435v10#bib.bib385)\], MGSM \[[386](https://arxiv.org/html/2307.06435v10#bib.bib386)\], MultiArith \[[387](https://arxiv.org/html/2307.06435v10#bib.bib387)\], ASDiv \[[388](https://arxiv.org/html/2307.06435v10#bib.bib388)\], MAWPS \[[389](https://arxiv.org/html/2307.06435v10#bib.bib389)\], SVAMP \[[390](https://arxiv.org/html/2307.06435v10#bib.bib390)\]

Problem Solving

HumanEval \[[141](https://arxiv.org/html/2307.06435v10#bib.bib141)\], DS-1000 \[[391](https://arxiv.org/html/2307.06435v10#bib.bib391)\], MBPP \[[392](https://arxiv.org/html/2307.06435v10#bib.bib392)\], APPS \[[382](https://arxiv.org/html/2307.06435v10#bib.bib382)\], CodeContests \[[142](https://arxiv.org/html/2307.06435v10#bib.bib142)\]

Natural Language Inference

& Logical Reasoning

ANLI \[[393](https://arxiv.org/html/2307.06435v10#bib.bib393)\], MNLI-m \[[394](https://arxiv.org/html/2307.06435v10#bib.bib394)\], MNLI-mm \[[394](https://arxiv.org/html/2307.06435v10#bib.bib394)\],QNLI \[[362](https://arxiv.org/html/2307.06435v10#bib.bib362)\], WNLI \[[357](https://arxiv.org/html/2307.06435v10#bib.bib357)\], OCNLI \[[311](https://arxiv.org/html/2307.06435v10#bib.bib311)\], CMNLI \[[311](https://arxiv.org/html/2307.06435v10#bib.bib311)\], ANLI R1 \[[393](https://arxiv.org/html/2307.06435v10#bib.bib393)\], ANLI R2 \[[393](https://arxiv.org/html/2307.06435v10#bib.bib393)\], ANLI R3 \[[393](https://arxiv.org/html/2307.06435v10#bib.bib393)\], HANS \[[395](https://arxiv.org/html/2307.06435v10#bib.bib395)\], OCNLI-FC \[[312](https://arxiv.org/html/2307.06435v10#bib.bib312)\], LogiQA \[[396](https://arxiv.org/html/2307.06435v10#bib.bib396)\], StrategyQA \[[349](https://arxiv.org/html/2307.06435v10#bib.bib349)\]

Cross-Lingual Understanding

MLQA \[[397](https://arxiv.org/html/2307.06435v10#bib.bib397)\], XNLI \[[398](https://arxiv.org/html/2307.06435v10#bib.bib398)\], PAWS-X \[[399](https://arxiv.org/html/2307.06435v10#bib.bib399)\], XSum \[[400](https://arxiv.org/html/2307.06435v10#bib.bib400)\], XCOPA \[[401](https://arxiv.org/html/2307.06435v10#bib.bib401)\], XWinograd \[[402](https://arxiv.org/html/2307.06435v10#bib.bib402)\], TyDiQA-GoldP \[[403](https://arxiv.org/html/2307.06435v10#bib.bib403)\], MLSum \[[404](https://arxiv.org/html/2307.06435v10#bib.bib404)\]

Truthfulness and Fact Checking

TruthfulQA \[[405](https://arxiv.org/html/2307.06435v10#bib.bib405)\], MultiFC \[[406](https://arxiv.org/html/2307.06435v10#bib.bib406)\], Fact Checking on Fever \[[407](https://arxiv.org/html/2307.06435v10#bib.bib407)\]

Biases and Ethics in AI

ETHOS \[[408](https://arxiv.org/html/2307.06435v10#bib.bib408)\], StereoSet \[[409](https://arxiv.org/html/2307.06435v10#bib.bib409)\], BBQ \[[410](https://arxiv.org/html/2307.06435v10#bib.bib410)\], Winobias \[[411](https://arxiv.org/html/2307.06435v10#bib.bib411)\], CrowS-Pairs \[[412](https://arxiv.org/html/2307.06435v10#bib.bib412)\]

Toxicity

RealToxicityPrompts \[[413](https://arxiv.org/html/2307.06435v10#bib.bib413)\], CivilComments toxicity classification \[[414](https://arxiv.org/html/2307.06435v10#bib.bib414)\]

Language Translation

WMT \[[415](https://arxiv.org/html/2307.06435v10#bib.bib415)\], WMT20 \[[416](https://arxiv.org/html/2307.06435v10#bib.bib416)\], WMT20-enzh \[[416](https://arxiv.org/html/2307.06435v10#bib.bib416)\], EPRSTMT \[[312](https://arxiv.org/html/2307.06435v10#bib.bib312)\], CCPM \[[417](https://arxiv.org/html/2307.06435v10#bib.bib417)\]

Scientific Knowledge

AminoProbe \[[148](https://arxiv.org/html/2307.06435v10#bib.bib148)\], BioLAMA \[[148](https://arxiv.org/html/2307.06435v10#bib.bib148)\], Chemical Reactions \[[148](https://arxiv.org/html/2307.06435v10#bib.bib148)\], Galaxy Clusters \[[148](https://arxiv.org/html/2307.06435v10#bib.bib148)\], Mineral Groups \[[148](https://arxiv.org/html/2307.06435v10#bib.bib148)\]

Dialogue

Wizard of Wikipedia \[[418](https://arxiv.org/html/2307.06435v10#bib.bib418)\], Empathetic Dialogues \[[419](https://arxiv.org/html/2307.06435v10#bib.bib419)\], DPC-generated \[[96](https://arxiv.org/html/2307.06435v10#bib.bib96)\] dialogues, ConvAI2 \[[420](https://arxiv.org/html/2307.06435v10#bib.bib420)\], KdConv \[[421](https://arxiv.org/html/2307.06435v10#bib.bib421)\]

Topic Classification

TNEWS-FC \[[312](https://arxiv.org/html/2307.06435v10#bib.bib312)\], YNAT \[[315](https://arxiv.org/html/2307.06435v10#bib.bib315)\], KLUE-TC \[[315](https://arxiv.org/html/2307.06435v10#bib.bib315)\], CSL \[[311](https://arxiv.org/html/2307.06435v10#bib.bib311)\], CSL-FC \[[312](https://arxiv.org/html/2307.06435v10#bib.bib312)\], IFLYTEK \[[422](https://arxiv.org/html/2307.06435v10#bib.bib422)\]

#### 5.2.1 Multi-task

 _MMLU \[[307](https://arxiv.org/html/2307.06435v10#bib.bib307)\]:_ A benchmark that measures the knowledge acquired by models during pretraining and evaluates models in zero-shot and few-shot settings across 57 subjects, testing both world knowledge and problem-solving ability.

 _SuperGLUE \[[2](https://arxiv.org/html/2307.06435v10#bib.bib2)\]:_ A more challenging and diverse successor to the GLUE \[[309](https://arxiv.org/html/2307.06435v10#bib.bib309)\] benchmark, SuperGLUE includes a variety of language understanding tasks, such as question answering, natural language inference, and co-reference resolution. It is designed to provide a rigorous test of language understanding and requires significant progress in areas like sample-efficient, transfer, multi-task, and unsupervised or self-supervised learning.

 _BIG-bench \[[308](https://arxiv.org/html/2307.06435v10#bib.bib308)\]:_ The BIG-bench (Behavior of Intelligent Generative Models Benchmark) is a large-scale benchmark designed to test the abilities of LLMs across a wide range of tasks, including reasoning, creativity, ethics, and understanding of specific domains.

 _GLUE \[[309](https://arxiv.org/html/2307.06435v10#bib.bib309)\]:_ The General Language Understanding Evaluation (GLUE) benchmark is a collection of resources for training, evaluating, and analyzing natural language understanding systems. It includes a variety of tasks that test a wide range of linguistic phenomena, making it a comprehensive tool for evaluating language understanding in AI.

#### 5.2.2 Language Understanding

 _WinoGrande \[[354](https://arxiv.org/html/2307.06435v10#bib.bib354)\]:_ A large-scale dataset inspired by the original Winograd \[[357](https://arxiv.org/html/2307.06435v10#bib.bib357)\] Schema Challenge tests models on their ability to resolve pronoun ambiguity and encourages the development of models that understand the broad context in natural language text.

 _CoQA \[[316](https://arxiv.org/html/2307.06435v10#bib.bib316)\]:_ A conversational question-answering dataset, CoQA challenges models with questions that rely on conversation history and require free-form text answers. Its diverse content from seven domains makes it a rigorous test for models’ ability to handle a wide range of topics and conversational contexts.

 _WiC \[[317](https://arxiv.org/html/2307.06435v10#bib.bib317)\]:_ This dataset assesses a model’s ability to discern word meanings based on context, aiding in tasks related to Word Sense Disambiguation.

 _Wikitext103 \[[318](https://arxiv.org/html/2307.06435v10#bib.bib318)\]:_ With over 100 million tokens from Wikipedia’s top articles, this dataset is a rich resource for tasks that require understanding long-term dependencies, such as language modeling and translation.

 _PG19 \[[319](https://arxiv.org/html/2307.06435v10#bib.bib319)\]:_ This is a digital library of diverse books from Project Gutenberg. It is specifically designed to facilitate research in unsupervised learning and language modeling, with a special focus on long-form content.

 _C4 \[[10](https://arxiv.org/html/2307.06435v10#bib.bib10)\]:_ A clean, multilingual dataset, C4 offers billions of tokens from web-crawled data. It is a comprehensive resource for training advanced Transformer models on various languages.

 _LCQMC \[[320](https://arxiv.org/html/2307.06435v10#bib.bib320)\]:_ The Large-scale Chinese Question Matching Corpus (LCQMC) is a dataset for evaluating the performance of models in semantic matching tasks. It contains pairs of questions in Chinese and their matching status, making it a valuable resource for research in Chinese language understanding.

#### 5.2.3 Story Cloze and Sentence Completion

 _StoryCloze \[[334](https://arxiv.org/html/2307.06435v10#bib.bib334)\]:_ It introduces a new “StoryCloze Test”, a commonsense reasoning framework for evaluating story understanding, generation, and script learning. It considers a model’s ability to understand and generate coherent and sensible stories.

 _LAMBADA \[[335](https://arxiv.org/html/2307.06435v10#bib.bib335)\]:_ This dataset evaluates contextual text understanding through a word prediction task. Models must predict the last word of a passage, which is easy for humans when given the whole passage, but not when given only the last sentence.

#### 5.2.4 Physical Knowledge and World Understanding

 _PIQA \[[340](https://arxiv.org/html/2307.06435v10#bib.bib340)\]:_ A dataset that probes the physical knowledge of models, aiming to understand how well they are learning about the real world.

 _TriviaQA \[[341](https://arxiv.org/html/2307.06435v10#bib.bib341)\]:_ A dataset that tests models on reading comprehension and open domain question answering (QA) tasks, with a focus on Information Retrieval (IR)-style QA.

 _ARC \[[342](https://arxiv.org/html/2307.06435v10#bib.bib342)\]:_ A larger version of the ARC-Challenge, this dataset contains both easy and challenging grade-school level, multiple-choice science questions. It is a comprehensive test of a model’s ability to understand and answer complex questions.

 _ARC-Easy \[[342](https://arxiv.org/html/2307.06435v10#bib.bib342)\]:_ A subset of the ARC dataset, ARC-Easy, contains questions that are answered correctly by either a retrieval-based algorithm or a word co-occurrence algorithm. It is a great starting point for models beginning to explore advanced question-answering.

 _ARC-Challenge \[[342](https://arxiv.org/html/2307.06435v10#bib.bib342)\]:_ A rigorous question-answering dataset, ARC-Challenge includes complex, grade-school level questions that demand reasoning beyond simple retrieval, testing the true comprehension capabilities of models.

#### 5.2.5 Contextual Language Understanding

 _RACE \[[347](https://arxiv.org/html/2307.06435v10#bib.bib347)\]:_ The RACE dataset is a reading comprehension dataset collected from English examinations in China, which benchmarks AI models for understanding and answering questions on long and complex passages, simulating the challenge of a real-world examination.

 _RACE-Middle \[[347](https://arxiv.org/html/2307.06435v10#bib.bib347)\]:_ Another subset of the RACE \[[347](https://arxiv.org/html/2307.06435v10#bib.bib347)\] dataset, RACE-Middle, contains middle school-level English exam questions. It offers a slightly less challenging but academically oriented evaluation of a model’s comprehension skills.

 _RACE-High \[[347](https://arxiv.org/html/2307.06435v10#bib.bib347)\]:_ A subset of the RACE \[[347](https://arxiv.org/html/2307.06435v10#bib.bib347)\] dataset, RACE-High consists of high school-level English exam questions. It is designed to evaluate the comprehension ability of models in a more academic and challenging context.

 _QuAC \[[348](https://arxiv.org/html/2307.06435v10#bib.bib348)\]:_ This dataset simulates an information-seeking dialog between students and teachers using hidden Wikipedia text. It introduces unique challenges not found in machine comprehension datasets, making it a valuable resource for advancing dialog systems.

#### 5.2.6 Commonsense Reasoning

 _HellaSwag \[[355](https://arxiv.org/html/2307.06435v10#bib.bib355)\]:_ A dataset that challenges models to pick the best ending to a context uses Adversarial Filtering to create a ‘Goldilocks’ zone of complexity, where generated text is absurd to humans but often misclassified by models.

 _COPA \[[401](https://arxiv.org/html/2307.06435v10#bib.bib401)\]:_ This dataset evaluates a model’s progress in open-domain commonsense causal reasoning. Each question comprises a premise and two alternatives, and the model must select the more plausible alternative, testing a model’s ability to understand and reason about cause and effect.

 _WSC \[[357](https://arxiv.org/html/2307.06435v10#bib.bib357)\]:_ The Winograd Schema Challenge (WSC) is a reading comprehension task in which a system must resolve references in a text, often requiring world knowledge and reasoning about the text.

 _CSQA \[[358](https://arxiv.org/html/2307.06435v10#bib.bib358)\]:_ The CommonsenseQA is a question-answering dataset that requires commonsense knowledge to evaluate the ability of AI models to understand and answer questions.

#### 5.2.7 Reading Comprehension

 _BoolQ \[[363](https://arxiv.org/html/2307.06435v10#bib.bib363)\]:_ A dataset derived from Google search queries, BoolQ challenges models to answer binary (yes/no) questions. The questions are naturally occurring and are paired with a paragraph from a Wikipedia article containing the answer. It is a test of reading comprehension and reasoning.

 _SQUADv2 \[[364](https://arxiv.org/html/2307.06435v10#bib.bib364)\]:_ The Stanford Question Answering Dataset (SQuAD) \[[362](https://arxiv.org/html/2307.06435v10#bib.bib362)\] is a collection of questions posed by crowd workers on a set of Wikipedia articles, where the answer to every question is a segment of text from the corresponding reading passage. SQuADv2 combines the original SQuAD1.1 dataset with over 50,000 unanswerable questions. The aim is to evaluate a model’s ability to understand and answer questions based on a given context and to determine when a question is unanswerable.

 _DROP \[[365](https://arxiv.org/html/2307.06435v10#bib.bib365)\]:_ DROP, or Discrete Reasoning Over the content of Paragraphs, is designed to test a model’s ability to understand a wide variety of reading phenomena. It encourages comprehensive and reliable evaluation of reading comprehension capabilities.

 _RTE \[[366](https://arxiv.org/html/2307.06435v10#bib.bib366)\]:_ The Recognizing Textual Entailment (RTE) datasets come from a series of annual competitions on textual entailment, predicting whether a given sentence logically follows from another and evaluating a model’s understanding of logical relationships in a text.

 _WebQA \[[367](https://arxiv.org/html/2307.06435v10#bib.bib367)\]:_ A dataset for open-domain question answering, WebQA offers a large collection of web-based question-answer pairs. It is designed to assess the ability of AI models to understand and answer questions based on web content.

 _CMRC2018 \[[369](https://arxiv.org/html/2307.06435v10#bib.bib369)\]:_ This dataset is a test of Chinese language models’ ability to reason comprehensively and is designed with a challenging span-extraction format that pushes the boundaries of machine performance.

#### 5.2.8 Mathematical Reasoning

 _MATH \[[382](https://arxiv.org/html/2307.06435v10#bib.bib382)\]:_ This dataset is a platform for evaluating the mathematical problem-solving abilities of AI models. It contains a diverse set of math problems, ranging from arithmetic to calculus, and is designed to test the model’s ability to understand and solve complex mathematical problems.

 _Math23k \[[383](https://arxiv.org/html/2307.06435v10#bib.bib383)\]:_ This one challenges a model’s ability to understand and solve mathematical word problems. It contains 23,000 Chinese arithmetic word problems that require models to perform reasoning and computation based on the problem description.

 _GSM8K \[[384](https://arxiv.org/html/2307.06435v10#bib.bib384)\]:_ A dataset of diverse grade school math word problems, testing a model’s ability to perform multi-step mathematical reasoning.

#### 5.2.9 Problem Solving and Logical Reasoning

 _ANLI \[[393](https://arxiv.org/html/2307.06435v10#bib.bib393)\]:_ A large-scale dataset designed to test the robustness of machine learning models in Natural Language Inference (NLI) is created through an iterative, adversarial process where humans try to generate examples that models cannot correctly classify.

 _HumanEval \[[141](https://arxiv.org/html/2307.06435v10#bib.bib141)\]:_ A dataset for evaluating the problem-solving ability of AI models, which includes a diverse set of tasks that require various cognitive abilities, making it a comprehensive tool for assessing general intelligence in AI.

 _StrategyQA \[[349](https://arxiv.org/html/2307.06435v10#bib.bib349)\]:_ A question-answering dataset that requires reasoning over multiple pieces of evidence to evaluate the strategic reasoning ability of AI models, pushing the boundaries of what machines can understand and answer.

#### 5.2.10 Cross-Lingual Understanding

 _XNLI \[[398](https://arxiv.org/html/2307.06435v10#bib.bib398)\]:_ A cross-lingual benchmark, XNLI extends the MultiNLI \[[429](https://arxiv.org/html/2307.06435v10#bib.bib429)\] corpus to 15 languages, including low-resource ones like Urdu. It tests models on cross-lingual sentence understanding, with 112,500 annotated pairs across three categories: entailment, contradiction, and neutral.

 _PAWS-X \[[399](https://arxiv.org/html/2307.06435v10#bib.bib399)\]:_ PAWS-X, or Cross-lingual Paraphrase Adversaries from Word Scrambling, is a multilingual version of the PAWS \[[430](https://arxiv.org/html/2307.06435v10#bib.bib430)\] dataset for paraphrase identification. It includes examples in seven languages and is designed to evaluate the performance of cross-lingual paraphrase identification models.

#### 5.2.11 Truthfulness

 _Truthful-QA \[[405](https://arxiv.org/html/2307.06435v10#bib.bib405)\]:_ A unique benchmark that measures a language model’s truthfulness when generating answers. The dataset includes questions across various categories like health, law, and politics, some designed to test the model against common human misconceptions.

#### 5.2.12 Biases and Ethics in AI

 _ETHOS \[[408](https://arxiv.org/html/2307.06435v10#bib.bib408)\]:_ ETHOS is a hate speech detection dataset built from YouTube and Reddit comments. It is a tool in the fight against online hate speech, offering binary and multi-label variants for robust content moderation.

 _StereoSet \[[409](https://arxiv.org/html/2307.06435v10#bib.bib409)\]:_ StereoSet is a comprehensive dataset designed to measure and evaluate the presence of stereotypical biases in language models. It focuses on four key domains: gender, profession, race, and religion. Contrasting stereotypical bias against language modeling ability provides a valuable tool for understanding and mitigating biases in large language models.

## 6 Applications

Applying Large Language Models (LLMs) to a variety of downstream tasks has become a popular trend in both AI-related research communities and industries, with many emerging uses being discovered and explored daily. LLMs, which are capable of understanding and generating human-like text, have found meaningful applications across a variety of fields. This section provides an overview of LLM applications in medicine, education, science, mathematics, law, finance, robotics, and coding. While each of these domains pose different challenges, LLMs open up opportunities to make significant contributions to these domains through their generalizability.  
_General Purpose:_ LLMs are being widely considered as general-purpose tools for a wide variety of tasks \[[431](https://arxiv.org/html/2307.06435v10#bib.bib431)\]. This is due to their inherent ability to understand, generate, and manipulate human-like text in a contextually relevant manner. This allows them to perform tasks ranging from simple language translation and question-answering to more complex tasks like summarization, text generation, and even programming help \[[432](https://arxiv.org/html/2307.06435v10#bib.bib432)\]. The utility of LLMs is further enhanced by their ability to adapt to the specific style and tone of the text they are processing, making the outputs more user-friendly and context-aware. In everyday applications, LLMs can be used as personal assistants, helping users draft emails or schedule appointments \[[433](https://arxiv.org/html/2307.06435v10#bib.bib433)\]; they can also be deployed in customer service to handle common questions or applied to generate content for digital platforms like websites by creating human-like text based on given prompts \[[434](https://arxiv.org/html/2307.06435v10#bib.bib434)\]. Moreover, LLMs play a crucial role in data analysis, where they can filter large volumes of text data, summarize key points, and find patterns that would take humans much longer to identify \[[435](https://arxiv.org/html/2307.06435v10#bib.bib435)\]. Despite their wide-ranging applications, it is essential to remember that LLMs, similar to any AI system, are only as good as the data they have been trained on.  
_Medicine:_ The application of LLMs in the field of medicine is reshaping healthcare delivery and research. For example, LLMs are increasingly used in clinical decision support systems to provide physicians with evidence-based treatment recommendations \[[436](https://arxiv.org/html/2307.06435v10#bib.bib436), [437](https://arxiv.org/html/2307.06435v10#bib.bib437), [438](https://arxiv.org/html/2307.06435v10#bib.bib438)\]. By analyzing patient data and medical literature, they can help identify potential diagnoses, suggest appropriate tests, and recommend optimal treatment strategies. Moreover, LLMs can also enhance patient interactions with healthcare systems; e.g., they can be used in chatbot applications \[[439](https://arxiv.org/html/2307.06435v10#bib.bib439), [440](https://arxiv.org/html/2307.06435v10#bib.bib440), [441](https://arxiv.org/html/2307.06435v10#bib.bib441)\] to answer patient queries about symptoms or medications, schedule appointments, and even provide essential health advice. For medical research, LLMs are used to extract and filter information from a considerable amount of medical literature, identify relevant studies, summarize findings, and even predict future research trends \[[442](https://arxiv.org/html/2307.06435v10#bib.bib442), [443](https://arxiv.org/html/2307.06435v10#bib.bib443), [444](https://arxiv.org/html/2307.06435v10#bib.bib444)\]. For medical education, LLMs can help create training materials, generate exam questions, provide detailed explanations of complex medical topics, and offer personalized feedback to students \[[445](https://arxiv.org/html/2307.06435v10#bib.bib445), [446](https://arxiv.org/html/2307.06435v10#bib.bib446), [447](https://arxiv.org/html/2307.06435v10#bib.bib447), [448](https://arxiv.org/html/2307.06435v10#bib.bib448)\]. They can also simulate patient interactions, enabling students to practice and improve their clinical skills. At a broader level, LLMs can assist in public health initiatives by analyzing media data to detect disease outbreaks, monitor public sentiment towards health policies, and disseminate health information in a clear and understandable manner \[[449](https://arxiv.org/html/2307.06435v10#bib.bib449)\]. LLMs can be employed to support public health initiatives, addressing related issues such as data privacy, the necessity for explainability, and the potential risk of propagating biases \[[450](https://arxiv.org/html/2307.06435v10#bib.bib450), [451](https://arxiv.org/html/2307.06435v10#bib.bib451)\].  
_Education:_ The integration of LLMs into the educational sector offers opportunities to enhance learning experiences, teacher support, and educational content development. For students, by analyzing their learning styles, performance, and preferences, LLMs can provide customized study materials and practice questions to develop personalized learning experiences \[[452](https://arxiv.org/html/2307.06435v10#bib.bib452)\]. For teachers, LLMs can help to create lesson plans and grade assignments and generate diverse and inclusive educational content, significantly saving more time for teaching and student interaction \[[453](https://arxiv.org/html/2307.06435v10#bib.bib453), [454](https://arxiv.org/html/2307.06435v10#bib.bib454)\]. In language learning, LLMs serve as advanced conversational partners capable of simulating conversations in multiple languages, correcting grammar, enhancing vocabulary, and aiding pronunciation for the needs of fluency in practice \[[455](https://arxiv.org/html/2307.06435v10#bib.bib455)\]. Furthermore, LLMs improve accessibility in education by providing support for students with disabilities. They can generate real-time transcriptions for the hearing impaired, offer reading assistance for the visually impaired, and simplify complex texts for those with learning disabilities \[[451](https://arxiv.org/html/2307.06435v10#bib.bib451)\]. As LLMs continue to evolve, their applications in education can benefit more students and teachers from different perspectives in practice.  
_Science:_ Similar to medical applications, LLMs can expedite the research process by quickly analyzing and summarizing scientific literature. By briefing comprehensible and accessible research summaries, LLMs can assist researchers in staying up-to-date with the latest findings, even in fields outside their area of expertise \[[456](https://arxiv.org/html/2307.06435v10#bib.bib456), [457](https://arxiv.org/html/2307.06435v10#bib.bib457)\]. In addition, LLMs can aid scientists in formulating new hypotheses and research questions since their ability to process large-scale datasets allows them to unveil insights that might not be immediately apparent to human researchers \[[458](https://arxiv.org/html/2307.06435v10#bib.bib458)\]. Moreover, for scientific writing, LLMs can help researchers draft documents, suggest improvements, and ensure adherence to specific formatting guidelines \[[459](https://arxiv.org/html/2307.06435v10#bib.bib459), [460](https://arxiv.org/html/2307.06435v10#bib.bib460)\]. This not only saves time but also improves the clarity of scientific communication, enabling interdisciplinary teams to work together more effectively.  
_Maths:_ In addition to providing mathematical research and education support, LLMs can assist in solving mathematical problems by giving step-by-step explanations and guiding users through complex proofs and calculations. They can help identify errors in reasoning or computation and suggest corrections, serving as an invaluable tool for both learning and verification purposes \[[461](https://arxiv.org/html/2307.06435v10#bib.bib461), [462](https://arxiv.org/html/2307.06435v10#bib.bib462)\]. LLMs can be employed to check the validity of mathematical proofs, offering a preliminary filter before human review. While they are not a substitute for the meticulous work of mathematicians, they can help simplify the process of proof verification \[[463](https://arxiv.org/html/2307.06435v10#bib.bib463), [464](https://arxiv.org/html/2307.06435v10#bib.bib464)\]. Moreover, LLMs enhance accessibility to mathematics by translating complex concepts and findings into understandable language for non-specialists \[[465](https://arxiv.org/html/2307.06435v10#bib.bib465)\], where the gap between theoretical mathematics and applied contexts such as physics, engineering, and economics can be bridged.  
_Law:_ LLMs can assist with the thematic analysis of legal documents, including generating initial coding for datasets, identifying themes, and classifying data according to these themes. This collaborative effort between legal experts and LLMs has proved to be effective in analyzing legal texts such as court opinions on theft, improving both the efficiency and quality of the research \[[466](https://arxiv.org/html/2307.06435v10#bib.bib466)\]. Additionally, LLMs have been evaluated for their ability to generate explanations of legal terms, focusing on improving factual accuracy and relevance by incorporating sentences from case law. By feeding relevant case law into the LLM, the augmented models can generate higher-quality explanations with less factually incorrect information \[[467](https://arxiv.org/html/2307.06435v10#bib.bib467)\]. Moreover, LLMs can be trained with specialized domain knowledge to perform legal reasoning tasks \[[468](https://arxiv.org/html/2307.06435v10#bib.bib468)\] and answer legal questions \[[469](https://arxiv.org/html/2307.06435v10#bib.bib469)\].  
_Finance:_ LLMs like BloombergGPT \[[151](https://arxiv.org/html/2307.06435v10#bib.bib151)\], trained on extensive proprietary financial datasets, exhibit superior performance on financial tasks. This indicates the value of domain-specific training in creating LLMs that can more accurately understand and process industry-specific language and concepts. The introduction of FinGPT \[[470](https://arxiv.org/html/2307.06435v10#bib.bib470)\] as an open-source model offers transparent and accessible resources to develop novel applications such as robo-advising, algorithmic trading, and low-code solutions, ultimately expanding the capabilities of financial services. Both BloombergGPT and FinGPT show the adaptability of LLMs to the financial domain, with the former showing the power of custom datasets and the latter emphasizing a data-centric approach and low-rank adaptation techniques for customization. Moreover, LLMs demonstrate an ability to break down complex financial tasks into actionable plans, enabling end-to-end solutions that were previously unfeasible with a single model \[[471](https://arxiv.org/html/2307.06435v10#bib.bib471)\].  
_Robotics:_ In robotics research, LLMs have promising applications, such as enhancing human-robot interaction \[[28](https://arxiv.org/html/2307.06435v10#bib.bib28), [472](https://arxiv.org/html/2307.06435v10#bib.bib472), [473](https://arxiv.org/html/2307.06435v10#bib.bib473), [474](https://arxiv.org/html/2307.06435v10#bib.bib474)\], task planning \[[237](https://arxiv.org/html/2307.06435v10#bib.bib237)\], motion planning \[[246](https://arxiv.org/html/2307.06435v10#bib.bib246)\], navigation \[[246](https://arxiv.org/html/2307.06435v10#bib.bib246), [475](https://arxiv.org/html/2307.06435v10#bib.bib475)\], object manipulation \[[236](https://arxiv.org/html/2307.06435v10#bib.bib236)\], personalized robots \[[476](https://arxiv.org/html/2307.06435v10#bib.bib476)\], etc. LLMs enable robots to understand the environment effectively and generate plans to complete tasks collaboratively \[[240](https://arxiv.org/html/2307.06435v10#bib.bib240), [26](https://arxiv.org/html/2307.06435v10#bib.bib26)\]. They can facilitate continuous learning by allowing robots to access and integrate information from a wide range of sources, helping robots acquire new skills, adapt to changes, and refine their paths \[[224](https://arxiv.org/html/2307.06435v10#bib.bib224), [233](https://arxiv.org/html/2307.06435v10#bib.bib233), [234](https://arxiv.org/html/2307.06435v10#bib.bib234)\].

## 7 Challenges and Future Directions

LLMs such as GPT-4 and its predecessors have significantly advanced natural language processing. Nevertheless, they also bring along a set of challenges. The computational cost, adversarial robustness, and interpretability are among the technical challenges that are intrinsic to these models. Furthermore, as these models are scaled up to handle more complex tasks or to operate in more complex or dynamic environments, new challenges in scalability, privacy, and real-time processing emerge. On the frontier of foundational research, integrating multi-modality and the effectiveness of transfer learning are being keenly explored. Additionally, the continuous learning aspect of these models, which aims to have models that can adapt to new information over time, presents a fresh set of challenges. These challenges not only underscore the technical intricacies involved but also highlight the broader impact and the future trajectory of LLMs in real-world applications. The following sections delve into these challenges, shedding light on the ongoing and potential efforts to address them.  
_Computational Cost:_ Training LLMs require extensive computational resources, which increases production costs and raises environmental concerns due to substantial energy consumption during large-scale training. Improved performance occurs as computational resources increase, but the rate of improvement gradually decreases when both the model and dataset size remain fixed, following the power law of diminishing returns \[[477](https://arxiv.org/html/2307.06435v10#bib.bib477)\].  
_Bias and Fairness:_ LLMs can inherit and amplify societal biases in their training data. These biases can manifest in the model’s outputs, leading to potential ethical and fairness issues \[[478](https://arxiv.org/html/2307.06435v10#bib.bib478)\].  
_Overfitting:_ Although LLMs possess substantial learning capabilities, they are susceptible to overfitting noisy and peculiar patterns within their extensive training data. Consequently, this may cause them to generate illogical responses \[[479](https://arxiv.org/html/2307.06435v10#bib.bib479)\]. The debate about Memorization vs. Generalization in LLMs is about finding the right balance. Memorization allows the model to remember specific details from its training data, ensuring it can provide accurate answers to precise questions. However, generalization enables the model to make inferences and produce responses for inputs it has not seen before, which is essential for handling various real-world tasks. Striking the right balance is the challenge: too much memorization can lead to overfitting, making the model inflexible and struggling with new inputs \[[480](https://arxiv.org/html/2307.06435v10#bib.bib480)\].  
_Economic and Research Inequality:_ The high cost of training and deploying LLMs may make their development concentrated within well-funded organizations, potentially worsening economic and research inequalities in AI \[[481](https://arxiv.org/html/2307.06435v10#bib.bib481)\].  
_Reasoning and Planning:_ Some reasoning and planning tasks, even as seemingly simple as common-sense planning, which humans find easy, remain well beyond the current capabilities of LLMs evaluated using an assessment framework. This is not entirely unexpected, considering that LLMs primarily generate text completions based on likelihood and offer no solid guarantees in terms of reasoning abilities \[[482](https://arxiv.org/html/2307.06435v10#bib.bib482)\].  
_Hallucinations:_ LLMs exhibit “hallucinations", where they generate responses that, while sounding plausible, are incorrect or do not align with the provided information \[[483](https://arxiv.org/html/2307.06435v10#bib.bib483)\]. Hallucinations can be categorized into three categories.

*   1.
    
    Input-conflicting hallucination, wherein LLMs produce content that diverges from the input given by users.
    
*   2.
    
    Context-conflicting hallucination, where LLMs generate content that contradicts information they have generated earlier.
    
*   3.
    
    Fact-conflicting hallucination involves LLM’s generation of content that does not align with established world knowledge.
    

_Prompt Engineering:_ Prompts serve as inputs to LLMs, and their syntax and semantics play a crucial role in determining the model’s output. The prompt variations, sometimes counter-intuitive to humans, can result in significant changes in model output and are addressed through prompt engineering, which involves designing natural language queries to guide LLMs responses effectively \[[484](https://arxiv.org/html/2307.06435v10#bib.bib484), [32](https://arxiv.org/html/2307.06435v10#bib.bib32)\].  
_Limited Knowledge:_ Information acquired during pretraining is limited and may become obsolete after some time. Re-training the model using updated data is costly. To generate factually accurate responses, people use a retrieval augmentation pipeline \[[198](https://arxiv.org/html/2307.06435v10#bib.bib198)\]. However, pre-trained models are not trained with retrieval augmentation generation (RAG) \[[6](https://arxiv.org/html/2307.06435v10#bib.bib6), [21](https://arxiv.org/html/2307.06435v10#bib.bib21)\]; hence, adapting the training pipeline is necessary \[[193](https://arxiv.org/html/2307.06435v10#bib.bib193), [25](https://arxiv.org/html/2307.06435v10#bib.bib25)\].  
_Safety and Controllability:_ Using LLMs comes with the risk of generating harmful, misleading, or inappropriate content, whether by accident or when given specific prompts. Ensuring these models are safely utilized is a significant concern \[[485](https://arxiv.org/html/2307.06435v10#bib.bib485)\].  
_Security and Privacy:_ LLMs are prone to leaking personal information and generating false, unethical, misaligned responses. Researchers have explored various security attacks, i.e., backdoor attacks, jailbreaking, prompt injection, and data poisoning, that lead to breaking LLMs security. Therefore, developing better defense mechanisms is essential to ensure LLMs are safe, reliable, and trustworthy for complex AI applications \[[486](https://arxiv.org/html/2307.06435v10#bib.bib486)\].  
_Multi-Modality:_ Multi-modal learning, where LLMs are trained on diverse data like text, images, and videos, aims to create models with richer understanding but faces challenges in data alignment, fusion strategies, and higher computational demands.  
_Catastrophic Forgetting:_ LLMs are often pre-trained on large datasets and then fine-tuned on domain-specific data, reducing training resources. However, they face issues like domain adaptation and catastrophic forgetting, which hinder the retention of original knowledge when learning new tasks.  
_Adversarial Robustness:_ Large Language Models (LLMs) have shown great capabilities in various tasks but are vulnerable to adversarial attacks, where slight, deliberate input alterations can mislead them. Especially with models like BERT, adversarial fine-tuning can enhance robustness, although it sometimes compromises generalization \[[487](https://arxiv.org/html/2307.06435v10#bib.bib487)\]. As LLMs integrate more into complex systems, examining their security properties becomes crucial, given the emerging field of adversarial attacks on LLMs within trustworthy ML \[[488](https://arxiv.org/html/2307.06435v10#bib.bib488)\]. This vulnerability is notable in safety-critical domains, necessitating robust adversarial evaluation tools to ensure LLM reliability \[[489](https://arxiv.org/html/2307.06435v10#bib.bib489)\].  
_Interpretability and Explainability:_ The “black-box” nature of LLMs poses challenges in understanding their decision-making, which is crucial for broader acceptance and trust, especially in sensitive domains. Despite their advanced capabilities, the lack of insight into their operation limits their effectiveness and trustworthiness \[[490](https://arxiv.org/html/2307.06435v10#bib.bib490), [491](https://arxiv.org/html/2307.06435v10#bib.bib491)\]. Efforts are being made to make LLMs more explainable to promote user trust and to ensure responsible AI usage. Understanding the logic behind LLMs’ responses is essential for fostering trust and ensuring they align with human values and legal standards.  
_Privacy Concerns:_ Privacy concerns in Large Language Models (LLMs) have escalated with their growth in complexity and size, particularly around data sharing and potential misuse. There is a risk of malicious content creation, filter bypass, and data privacy issues, especially in e-commerce, where protecting customer privacy is crucial. If models are trained on private data, additional concerns arise if such models are made publicly available. LLMs tend to memorize phrases from their training sets, which an adversary could exploit to extract sensitive data, posing a threat to personal privacy \[[492](https://arxiv.org/html/2307.06435v10#bib.bib492), [493](https://arxiv.org/html/2307.06435v10#bib.bib493)\].  
_Real-Time Processing:_ Real-time processing in Large Language Models (LLMs) is pivotal for various applications, especially with the rising popularity of mobile AI applications and concerns regarding information security and privacy. However, LLMs often have hundreds of layers and millions of parameters, which impede real-time processing due to the high computational demands and limited weight storage on hardware platforms, particularly in edge computing environments \[[494](https://arxiv.org/html/2307.06435v10#bib.bib494)\]. While certain efforts like MobileBERT aim to reduce memory requirements, they still face substantial execution overhead due to the large number of model layers, leading to high inference latency.  
_Long-Term Dependencies:_ Large Language Models have shown considerable progress in understanding and generating text, yet they often struggle with preserving context and handling long-term dependencies, particularly in complex, multi-turn conversations or long documents. This limitation can lead to incoherent or irrelevant responses.  
_Hardware Acceleration:_ The growth of LLMs presents significant hardware challenges due to the increasing computational and memory demands associated with training and deploying these models. GPUs have played a crucial role in meeting the hardware requirements for training LLMs, with the networking industry also evolving to optimize hardware for training workloads. However, the growing size of LLMs, which has been outpacing hardware progress, makes model inference increasingly costly. Model quantization is a promising approach to bridge the widening gap between LLM size and hardware capacity \[[495](https://arxiv.org/html/2307.06435v10#bib.bib495)\]. Although specialized hardware acceleration like GPUs or TPUs can significantly reduce the computational cost, making real-time applications more feasible, they may not fully resolve all limitations, necessitating further advancements in hardware technology.  
_Regulatory and Ethical Frameworks:_ The rapid advancements in artificial intelligence have given rise to sophisticated Large Language Models (LLMs) like OpenAI’s GPT-4 \[[157](https://arxiv.org/html/2307.06435v10#bib.bib157)\] and Google’s Bard. These developments underscore the imperative for regulatory oversight to manage the ethical and social challenges accompanying LLMs’ widespread use \[[496](https://arxiv.org/html/2307.06435v10#bib.bib496)\]. For instance, LLMs can generate content that can be used positively or negatively, emphasizing the need for proactive ethical frameworks and policy measures to guide their responsible use and assign accountability for their outputs \[[497](https://arxiv.org/html/2307.06435v10#bib.bib497)\]. Auditing is identified as a promising governance mechanism to ensure that AI systems, including LLMs, are designed and deployed ethically, legally, and technically robust \[[498](https://arxiv.org/html/2307.06435v10#bib.bib498)\].  

## 8 Conclusion

This article has comprehensively reviewed the developments in LLMs. It contributes to summarizing significant findings of LLMs in the existing literature and provides a detailed analysis of the design aspects, including architectures, datasets, and training pipelines. We identified crucial architectural components and training strategies employed by different LLMs. These aspects are presented as summaries and discussions throughout the article. Moreover, we have discussed the performance differences of LLMs in zero-shot and few-shot settings, explored the impact of fine-tuning, and compared supervised and generalized models and encoder vs. decoder vs. encoder-decoder architectures. A comprehensive review of multi-modal LLMs, retrieval augmented LLMs, LLMs-powered agents, efficient LLMs, datasets, evaluation, applications, and challenges is also provided. This article is anticipated to serve as a valuable resource for researchers, offering insights into the recent advancements in LLMs and providing fundamental concepts and details to develop better LLMs.  

Acknowledgement: The author/s would like to acknowledge the support received from Saudi Data and AI Authority (SDAIA) and King Fahd University of Petroleum and Minerals (KFUPM) under SDAIA-KFUPM Joint Research Center for Artificial Intelligence Grant No. JRC-AI-RFP-11.
